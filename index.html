<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warhammer List Compactor</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>

    <div class="container">
        <div class="card">
            <header class="header">
                <h1>Warhammer List Compactor</h1>
                <p>Paste your list below in "WTC" format to generate a compacted summary. Click "Copy Extended Version" for plain text output, or "Copy for Discord (Fancy)" for a colored Discord-friendly code block!</p>
            </header>

            <div class="grid-container">
                <!-- Input Column -->
                <div>
                    <label for="inputText" class="io-label">WTC Formatted List</label>
                    <textarea id="inputText" class="io-box"></textarea>
                    <div class="column-footer">
                        <div id="inputCharCount" class="char-count"></div>
                        <button id="parseButton" class="btn btn-primary">Compact this list</button>
                    </div>
                </div>

                <!-- Extended Output Column -->
                <div>
                    <label for="unabbreviatedOutput" class="io-label">Extended List</label>
                    <div id="unabbreviatedOutput" class="io-box"></div>
                     <div class="column-footer">
                        <div id="extendedCharCount" class="char-count"></div>
                        <button id="copyExtendedButton" class="btn btn-copy">Copy Extended Version</button>
                    </div>
                </div>

                <!-- Compacted Output Column -->
                <div>
                    <label for="compactedOutput" class="io-label">Compact List</label>
                    <div id="compactedOutput" class="io-box"></div>
                    <div class="column-footer">
                        <div id="compactCharCount" class="char-count"></div>
                        <div class="button-group">
                             <button id="copyCompactButton" class="btn btn-discord">Copy for Discord (Fancy)</button>
                             <button id="copyPlainDiscordButton" class="btn btn-discord">Copy Plain Text</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- App Footer with Contact Info -->
            <footer class="app-footer">
                <p>For feedback or questions, reach out to <a href="https://discord.com/users/Desjani" target="_blank">@Desjani</a> on Discord.</p>
            </footer>
        </div>
    </div>

    <script>
        // Store the parsed data globally within the script's scope
        let parsedData = null;
        let extendedPlainText = '';
        let compactPlainText = '';

        // --- Faction Themes ---
        const factionThemes = {
            "Chaos Daemons": { "--color-bg": "#4c1d4c", "--color-surface": "#6d286d", "--color-action": "#a855f7", "--color-action-hover": "#9333ea" },
            "Chaos Knights": { "--color-bg": "#262626", "--color-surface": "#404040", "--color-action": "#a1a1aa", "--color-action-hover": "#71717a" },
            "Chaos Space Marines": { "--color-bg": "#171717", "--color-surface": "#262626", "--color-action": "#ca8a04", "--color-action-hover": "#a16207" },
            "Death Guard": { "--color-bg": "#365314", "--color-surface": "#4d7c0f", "--color-action": "#84cc16", "--color-action-hover": "#65a30d" },
            "Emperor's Children": { "--color-bg": "#701a75", "--color-surface": "#86198f", "--color-action": "#d946ef", "--color-action-hover": "#c026d3" },
            "Thousand Sons": { "--color-bg": "#1e3a8a", "--color-surface": "#1e40af", "--color-action": "#3b82f6", "--color-action-hover": "#2563eb" },
            "World Eaters": { "--color-bg": "#4c1d1d", "--color-surface": "#7f1d1d", "--color-action": "#dc2626", "--color-action-hover": "#b91c1c" },
            "Adepta Sororitas": { "--color-bg": "#171717", "--color-surface": "#262626", "--color-action": "#dc2626", "--color-action-hover": "#b91c1c" },
            "Adeptus Custodes": { "--color-bg": "#78350f", "--color-surface": "#92400e", "--color-action": "#f59e0b", "--color-action-hover": "#d97706" },
            "Adeptus Mechanicus": { "--color-bg": "#7f1d1d", "--color-surface": "#991b1b", "--color-action": "#ef4444", "--color-action-hover": "#dc2626" },
            "Agents of the Imperium": { "--color-bg": "#262626", "--color-surface": "#404040", "--color-action": "#a1a1aa", "--color-action-hover": "#71717a" },
            "Astra Militarum": { "--color-bg": "#3f6212", "--color-surface": "#4d7c0f", "--color-action": "#84cc16", "--color-action-hover": "#65a30d" },
            "Grey Knights": { "--color-bg": "#374151", "--color-surface": "#4b5563", "--color-action": "#9ca3af", "--color-action-hover": "#6b7280" },
            "Imperial Knights": { "--color-bg": "#1e3a8a", "--color-surface": "#1e40af", "--color-action": "#f59e0b", "--color-action-hover": "#d97706" },
            "Black Templars": { "--color-bg": "#171717", "--color-surface": "#262626", "--color-action": "#e5e5e5", "--color-action-hover": "#a3a3a3" },
            "Blood Angels": { "--color-bg": "#7f1d1d", "--color-surface": "#991b1b", "--color-action": "#ef4444", "--color-action-hover": "#dc2626" },
            "Dark Angels": { "--color-bg": "#0f5132", "--color-surface": "#14532d", "--color-action": "#22c55e", "--color-action-hover": "#16a34a" },
            "Deathwatch": { "--color-bg": "#171717", "--color-surface": "#262626", "--color-action": "#9ca3af", "--color-action-hover": "#6b7280" },
            "Imperial Fists": { "--color-bg": "#854d0e", "--color-surface": "#a16207", "--color-action": "#facc15", "--color-action-hover": "#eab308" },
            "Iron Hands": { "--color-bg": "#171717", "--color-surface": "#262626", "--color-action": "#e5e5e5", "--color-action-hover": "#a3a3a3" },
            "Raven Guard": { "--color-bg": "#171717", "--color-surface": "#262626", "--color-action": "#e5e5e5", "--color-action-hover": "#a3a3a3" },
            "Salamanders": { "--color-bg": "#14532d", "--color-surface": "#166534", "--color-action": "#f59e0b", "--color-action-hover": "#d97706" },
            "Space Marines": { "--color-bg": "#1e3a8a", "--color-surface": "#1e40af", "--color-action": "#2563eb", "--color-action-hover": "#1d4ed8" },
            "Space Wolves": { "--color-bg": "#374151", "--color-surface": "#4b5563", "--color-action": "#facc15", "--color-action-hover": "#eab308" },
            "Ultramarines": { "--color-bg": "#1e3a8a", "--color-surface": "#1e40af", "--color-action": "#2563eb", "--color-action-hover": "#1d4ed8" },
            "White Scars": { "--color-bg": "#f9fafb", "--color-surface": "#f3f4f6", "--color-action": "#dc2626", "--color-action-hover": "#b91c1c" },
            "Aeldari": { "--color-bg": "#171717", "--color-surface": "#262626", "--color-action": "#fde047", "--color-action-hover": "#facc15" },
            "Drukhari": { "--color-bg": "#0f5132", "--color-surface": "#14532d", "--color-action": "#dc2626", "--color-action-hover": "#b91c1c" },
            "Genestealer Cults": { "--color-bg": "#4c1d4c", "--color-surface": "#6d286d", "--color-action": "#a855f7", "--color-action-hover": "#9333ea" },
            "Leagues of Votann": { "--color-bg": "#0e7490", "--color-surface": "#155e75", "--color-action": "#f97316", "--color-action-hover": "#ea580c" },
            "Necrons": { "--color-bg": "#262626", "--color-surface": "#404040", "--color-action": "#4ade80", "--color-action-hover": "#22c55e" },
            "Orks": { "--color-bg": "#14532d", "--color-surface": "#166534", "--color-action": "#22c55e", "--color-action-hover": "#16a34a" },
            "T'au Empire": { "--color-bg": "#854d0e", "--color-surface": "#a16207", "--color-action": "#f97316", "--color-action-hover": "#ea580c" },
            "Tyranids": { "--color-bg": "#4c1d4c", "--color-surface": "#6d286d", "--color-action": "#f472b6", "--color-action-hover": "#ec4899" }
        };

        // --- Abbreviation Database ---
        let factionAbbreviationDBs = {}; // Use let to allow reassignment

        document.addEventListener('DOMContentLoaded', () => {
            const parseButton = document.getElementById('parseButton');
            parseButton.disabled = true;
            parseButton.textContent = 'Loading DB...';

            fetch('./Wargear_tree.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    factionAbbreviationDBs = data;
                    console.log("Wargear database loaded successfully.");
                    parseButton.disabled = false;
                    parseButton.textContent = 'Compact this list';
                })
                .catch(error => {
                    console.error("Could not load wargear database:", error);
                    parseButton.textContent = 'Error: DB Load Failed';
                });
        })

        function flexibleItemMatch(rule, itemName) {
            const ruleItemLower = rule.item.toLowerCase();
            const itemNameLower = itemName.toLowerCase();
            if (ruleItemLower === itemNameLower) return true; // Exact match
            if (ruleItemLower === itemNameLower + 's') return true; // input: cutter, rule: cutters
            if (itemNameLower.endsWith('s') && ruleItemLower === itemNameLower.slice(0, -1)) return true; // input: cutters, rule: cutter
            return false;
        }

        function abbreviate(itemName, unitName, fullFactionKeyword) {
            const searchOrder = [];
            const mainFaction = fullFactionKeyword ? (fullFactionKeyword.split(' - ').pop() || fullFactionKeyword) : null;
            
            if (mainFaction) {
                searchOrder.push(mainFaction);
            }
            // Add broader categories for cross-faction rules.
            if (fullFactionKeyword.includes("Chaos")) {
                searchOrder.push("Chaos Space Marines", "Chaos Knights", "Chaos Daemons");
            }
            if (fullFactionKeyword.includes("Imperium")) {
                searchOrder.push("Imperial Knights", "Agents of the Imperium");
            }
            if (fullFactionKeyword.includes("Adeptus Astartes")) {
                searchOrder.push("Space Marines");
            }
            if (fullFactionKeyword.includes("Genestealer Cults") || fullFactionKeyword.includes("Tyranids")) {
                searchOrder.push("Genestealer Cults", "Tyranids");
            }
            const factionsToSearch = [...new Set(searchOrder)];

            // --- First Pass: Prioritize specific unit matches across all relevant factions ---
            for (const faction of factionsToSearch) {
                const rules = factionAbbreviationDBs[faction];
                if (!rules) continue;

                // Find the unit rules with a case-insensitive key match
                const unitRulesKey = Object.keys(rules).find(key => key.toLowerCase() === unitName.toLowerCase());
                const unitRules = unitRulesKey ? rules[unitRulesKey] : null;

                if (!unitRules) continue;

                // 1. Specific unit name, specific item name
                let foundRule = unitRules.find(rule => flexibleItemMatch(rule, itemName));
                if (foundRule) {
                    return foundRule.abbr;
                }
                // 2. Specific unit name, wildcard item ("*")
                foundRule = unitRules.find(rule => rule.item === "*");
                if (foundRule) {
                    return foundRule.abbr;
                }
            }

            // --- Second Pass: Check for wildcard unit matches if no specific unit match was found ---
            for (const faction of factionsToSearch) {
                const rules = factionAbbreviationDBs[faction];
                if (!rules || !rules["*"]) continue;

                let foundRule = null;
                // 3. Wildcard unit ("*"), specific item name
                foundRule = rules["*"].find(rule => flexibleItemMatch(rule, itemName));
                if (foundRule) {
                    return foundRule.abbr;
                }
                // 4. Wildcard unit ("*"), wildcard item ("*")
                foundRule = rules["*"].find(rule => rule.item === "*");
                if (foundRule) {
                    return foundRule.abbr;
                }
            }

            // If no abbreviation is found after checking all relevant factions, return the original item name
            return itemName;
        }
        document.getElementById('parseButton').addEventListener('click', () => {
            const text = document.getElementById('inputText').value;
            const lines = text.split('\n');
            const result = {};
            let currentSection = null, currentUnit = null, currentSubUnit = null, factionKeyword = null;

            const addItemToTarget = (target, itemString, unitContextName, itemType = 'wargear') => {
                if (!target || !itemString) return;
                const withMatch = itemString.match(/(\d+)\s+with\s+(.*)/);
                if (withMatch) {
                    const quantity = parseInt(withMatch[1]);
                    const items = withMatch[2].split(',').map(s => s.trim());
                    items.forEach(itemName => {
                        const { quantity: innerQuantity, name } = parseItemString(itemName);
                        const numericInnerQuantity = parseInt(innerQuantity.replace('x', ''), 10);
                        const totalQuantity = quantity * numericInnerQuantity;
                        const nameshort = abbreviate(name, unitContextName, factionKeyword);
                        const existingItem = target.items.find(item => item.name === name);
                        if (existingItem) {
                            const existingQty = parseInt(existingItem.quantity.replace('x', ''));
                            existingItem.quantity = `${existingQty + totalQuantity}x`;
                        } else {
                            target.items.push({ quantity: `${totalQuantity}x`, name, nameshort, items: [], type: itemType });
                        }
                    });
                    return;
                }
                const { quantity, name } = parseItemString(itemString);
                const nameshort = abbreviate(name, unitContextName, factionKeyword);
                const numericQuantity = parseInt(quantity.replace('x', ''), 10);
                const existingItem = target.items.find(item => item.name === name);
                if (existingItem) {
                    const existingQty = parseInt(existingItem.quantity.replace('x', ''));
                    existingItem.quantity = `${existingQty + numericQuantity}x`;
                } else {
                    target.items.push({ quantity, name, nameshort, items: [], type: itemType });
                }
            };

            const sectionHeaderRegex = /^[A-Z\s]+$/;
            const unitRegex = /^(\d+x?\s+)(.*?)(\s*\((\d+)\s*pts\))?$/;
            const summaryRegex = /^\+\s*([^:]+):\s*(.*)$/;
            const enhancementRegex = /^&\s*(.*)$/;
            const charLineRegex = /^(Char\d+):\s*(.*)/;
            const enhancementLineRegex = /^Enhancement:\s*(.*)/;
            const bulletItemRegex = /^\s*•\s*(.*)/;
            const indentedWithRegex = /^\s+(\d+)\s+with\s+(.*)/;
            const indentedBulletRegex = /^\s{2,}•\s*(.*)/;
            const simpleWithRegex = /^\d+\s+with\s+.*/;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();
                if (!trimmedLine) continue;

                // --- Handle non-unit lines first ---
                if (trimmedLine.startsWith('+') || trimmedLine.startsWith('&')) {
                    const summaryMatch = trimmedLine.match(summaryRegex);
                    const enhancementMatch = trimmedLine.match(enhancementRegex);
                    result.SUMMARY = result.SUMMARY || { ENHANCEMENT: [] };
                    if (summaryMatch) {
                        const key = summaryMatch[1].trim().replace(/\s+/g, '_');
                        const value = summaryMatch[2].trim();
                        if (key === 'ENHANCEMENT') result.SUMMARY.ENHANCEMENT.push(value);
                        else result.SUMMARY[key] = value;
                    } else if (enhancementMatch) {
                        result.SUMMARY.ENHANCEMENT.push(enhancementMatch[1].trim());
                    }
                    if (!factionKeyword && result.SUMMARY.FACTION_KEYWORD) {
                        factionKeyword = result.SUMMARY.FACTION_KEYWORD;
                    }
                    continue;
                }
                if (sectionHeaderRegex.test(trimmedLine) && !unitRegex.test(trimmedLine) && !charLineRegex.test(trimmedLine)) {
                    currentSection = trimmedLine;
                    result[currentSection] = result[currentSection] || [];
                    currentUnit = null;
                    currentSubUnit = null;
                    continue;
                }

                // --- Handle unit lines (Character or standard) ---
                const charMatch = trimmedLine.match(charLineRegex);
                const standardUnitMatch = trimmedLine.match(unitRegex);
                // A main unit is a character line, or any non-indented, non-bullet line that looks like a unit.
                const isMainUnitLine = (charMatch || (standardUnitMatch && !line.startsWith(' ') && !line.startsWith('\t') && !trimmedLine.startsWith('•'))) && !simpleWithRegex.test(trimmedLine);

                if (isMainUnitLine) {
                    currentSection = "CHARACTER";
                    if (!charMatch) {
                        currentSection = currentSection || "OTHER DATASHEETS";
                    }
                    result[currentSection] = result[currentSection] || [];
                    const unitContent = charMatch ? charMatch[2] : trimmedLine;
                    const finalUnitMatch = unitContent.match(unitRegex);

                    if (finalUnitMatch) {
                        currentUnit = {
                            quantity: finalUnitMatch[1] ? finalUnitMatch[1].trim() : '1x',
                            name: finalUnitMatch[2].trim(),
                            points: finalUnitMatch[4] ? parseInt(finalUnitMatch[4], 10) : 0,
                            items: []
                        };
                        result[currentSection].push(currentUnit);
                        currentSubUnit = null;
                    }
                    continue;
                }

                // --- Handle items within a unit (wargear, subunits, etc.) ---
                if (currentUnit) {
                    const bulletMatch = trimmedLine.match(bulletItemRegex);
                    const isIndented = line.startsWith(' ') || line.startsWith('\t');

                    if (bulletMatch) {
                        const itemContent = bulletMatch[1].trim();

                        // Ignore noise lines that just repeat a unit name
                        if (itemContent.toLowerCase() === currentUnit.name.toLowerCase() || (currentSubUnit && itemContent.toLowerCase() === currentSubUnit.name.toLowerCase())) {
                            continue;
                        }

                        if (isIndented) {
                            // Indented bullet is always wargear for the current context.
                            const target = currentSubUnit || currentUnit;
                            const itemType = itemContent.toLowerCase() === 'warlord' ? 'special' : 'wargear';
                            addItemToTarget(target, itemContent, currentUnit.name, itemType);
                        } else {
                            // Non-indented bullet. Could be a subunit or wargear for the main unit.
                            const subUnitMatch = itemContent.match(unitRegex);
                            if (subUnitMatch) {
                                // It looks like a subunit. Create it.
                                currentSubUnit = {
                                    quantity: subUnitMatch[1] ? subUnitMatch[1].trim() : '1x',
                                    name: subUnitMatch[2].trim(),
                                    points: 0,
                                    items: []
                                };
                                currentUnit.items.push(currentSubUnit);
                            } else {
                                // It's wargear for the main unit. Reset subunit context.
                                currentSubUnit = null;
                                const itemType = itemContent.toLowerCase() === 'warlord' ? 'special' : 'wargear';
                                addItemToTarget(currentUnit, itemContent, currentUnit.name, itemType);
                            }
                        }
                    } else if (isIndented) { // This handles indented lines without bullets
                        // This is an indented line without a bullet (e.g., a "with" line). It's wargear for the current context.
                        const target = currentSubUnit || currentUnit;
                        addItemToTarget(target, trimmedLine, currentUnit.name);
                    } else if (enhancementLineRegex.test(trimmedLine)) {
                        if (currentUnit) {
                            const enhancementContent = trimmedLine.match(enhancementLineRegex)[1].trim();
                            const pointsRegex = /\s*\((.*?)\)$/;
                            const pointsMatch = enhancementContent.match(pointsRegex);
                            
                            let enhancementName = enhancementContent;
                            let enhancementPoints = '';

                            if (pointsMatch) {
                                enhancementName = enhancementContent.replace(pointsRegex, '').trim();
                                enhancementPoints = `(${pointsMatch[1]})`;
                            }

                            const abbreviation = enhancementName.split(/[\s-]+/).map(word => word.charAt(0)).join('').toUpperCase();
                            const shortText = `${abbreviation} ${enhancementPoints}`.trim();
                            currentUnit.items.push({ quantity: '1x', name: `Enhancement: ${enhancementContent}`, nameshort: shortText, items: [], type: 'special' });
                        }
                    } else if (simpleWithRegex.test(trimmedLine)) {
                        // This is a non-indented "with" line, treat as wargear for the current context.
                        const target = currentSubUnit || currentUnit;
                        addItemToTarget(target, trimmedLine, currentUnit.name);
                    }
                }
            }
            parsedData = result;
            const extendedOutput = generateOutput(result, false);
            document.getElementById('unabbreviatedOutput').innerHTML = extendedOutput.html;
            extendedPlainText = extendedOutput.plainText;
            const compactOutput = generateOutput(result, true);
            document.getElementById('compactedOutput').innerHTML = compactOutput.html;
            compactPlainText = compactOutput.plainText;
            updateCharCounts();
            applyTheme(factionKeyword);
        });

        function parseItemString(itemString) {
            const match = itemString.match(/^(\d+x?\s+)?(.*)$/);
            if (match) {
                const quantity = match[1] ? match[1].trim() : '1x';
                const name = match[2].trim();
                return { quantity, name };
            }
            return { quantity: '1x', name: itemString };
        }

        function renderUnitItems(items, useAbbreviations, plainTextPrefix) {
            let html = '', plainText = '';
            const specialItems = items.filter(item => item.type === 'special');
            const wargearItems = items.filter(item => item.type !== 'special' && (!useAbbreviations || item.nameshort !== "NULL"));

            if (wargearItems.length > 0) {
                wargearItems.sort((a, b) => parseInt(b.quantity.replace('x', ''), 10) - parseInt(a.quantity.replace('x', ''), 10));
                const wargearStrings = wargearItems.map(item => {
                    const itemNumericQty = parseInt(item.quantity.replace('x', ''), 10);
                    const itemQtyDisplay = itemNumericQty > 1 ? `${itemNumericQty} ` : '';
                    const itemName = useAbbreviations ? item.nameshort : item.name;
                    return `${itemQtyDisplay}${itemName}`;
                });
                if (useAbbreviations) {
                    html += `<p style="margin: 0;">${wargearStrings.join(', ')}</p>`;
                    plainText += `${plainTextPrefix}${wargearStrings.join(', ')}\n`;
                } else {
                    wargearStrings.forEach(str => {
                        html += `<p style="margin: 0;">${str}</p>`;
                        plainText += `${plainTextPrefix}${str}\n`;
                    });
                }
            }

            if (specialItems.length > 0) {
                specialItems.forEach(item => {
                    const itemName = useAbbreviations ? item.nameshort : item.name;
                    html += `<p style="margin: 0;">${itemName}</p>`;
                    plainText += `${plainTextPrefix}${itemName}\n`;
                });
            }
            return { html, plainText };
        }

        function generateOutput(data, useAbbreviations) {
            let html = '', plainText = '';
            const factionKeyword = data.SUMMARY?.FACTION_KEYWORD || '';
            const faction = (factionKeyword.split(' - ').pop() || factionKeyword);
            if (data.SUMMARY) {
                const summaryParts = [];
                if (faction) summaryParts.push(faction);
                if (data.SUMMARY.DETACHMENT) summaryParts.push(`${data.SUMMARY.DETACHMENT}`);
                if (data.SUMMARY.TOTAL_ARMY_POINTS) summaryParts.push(`${data.SUMMARY.TOTAL_ARMY_POINTS}`);
                if (summaryParts.length > 0) {
                    const summaryText = summaryParts.join(' | ');
                    html += `<div style="padding-bottom: 0.5rem; border-bottom: 1px solid var(--color-border);"><p style="font-size: 0.75rem; margin-bottom: 0.25rem; color: var(--color-text-secondary); font-weight: 600;">${summaryText}</p></div>`;
                    plainText += summaryText + '\n-------------------------------------\n';
                }
            }
            html += `<div style="margin-top: 0.5rem;">`;
            let firstUnitOverall = true;
            for (const section in data) {
                if (section !== 'SUMMARY' && Array.isArray(data[section])) {
                    data[section].forEach(unit => {
                        const numericQuantity = parseInt(unit.quantity.replace('x', ''), 10);
                        const quantityDisplay = numericQuantity > 1 ? `${numericQuantity} ` : '';
                        const unitText = `${quantityDisplay}${unit.name} ${unit.points}`;
                        html += `<div><p style="color: var(--color-text-primary); font-weight: 600; font-size: 0.875rem; margin-bottom: 0.25rem;">${unitText}</p>`;
                        plainText += `* ${unitText}\n`;
                        if (unit.items && unit.items.length > 0) {
                            const hasVisibleItems = !useAbbreviations || unit.items.some(item => {
                                if (item.points !== undefined) { 
                                    return item.items && item.items.some(subItem => subItem.nameshort !== "NULL" || subItem.type === 'special');
                                }
                                return item.nameshort !== "NULL" || item.type === 'special';
                            });

                            if (hasVisibleItems) {
                                html += `<div style="padding-left: 1rem; font-size: 0.75rem; color: var(--color-text-secondary); font-weight: 400;">`;
                                const allItems = [...unit.items];
                                const topLevelItems = allItems.filter(item => item.points === undefined);
                                const subunitItems = allItems.filter(item => item.points !== undefined).sort((a, b) => parseInt(a.quantity.replace('x', ''), 10) - parseInt(b.quantity.replace('x', ''), 10));

                                const topLevelRender = renderUnitItems(topLevelItems, useAbbreviations, '  - ');
                                html += topLevelRender.html;
                                plainText += topLevelRender.plainText;

                                subunitItems.forEach(item => {
                                    const subUnitHasVisibleItems = !useAbbreviations || (item.items && item.items.some(subItem => subItem.nameshort !== "NULL" || subItem.type === 'special'));
                                    if (subUnitHasVisibleItems) {
                                        const itemNumericQty = parseInt(item.quantity.replace('x', ''), 10);
                                        const itemQtyDisplay = itemNumericQty > 1 ? `${itemNumericQty} ` : '';
                                        const itemText = `${itemQtyDisplay}${item.name}`;
                                        html += `<p style="font-weight: 500; color: var(--color-text-primary); margin: 0;">${itemText}</p>`;
                                        plainText += `  + ${itemText}\n`;

                                        const subunitRender = renderUnitItems(item.items, useAbbreviations, '    - ');
                                        html += `<div style="padding-left: 1rem;">${subunitRender.html}</div>`;
                                        plainText += subunitRender.plainText;
                                    }
                                });
                                html += `</div>`;
                            }
                        }
                        html += `</div>`;
                        firstUnitOverall = false;
                    });
                }
            }
            html += `</div>`;
            return { html, plainText };
        }    
    function updateCharCounts() {
            const originalSize = document.getElementById('inputText').value.length;
            const extendedSize = extendedPlainText.trim().length;
            const compactSize = compactPlainText.trim().length;
            
            document.getElementById('inputCharCount').textContent = `Characters: ${originalSize}`;

            if (originalSize > 0) {
                const extendedSavings = originalSize - extendedSize;
                const extendedSavingsPercent = ((extendedSavings / originalSize) * 100).toFixed(1);
                document.getElementById('extendedCharCount').innerHTML = `Characters: ${extendedSize} | Savings: ${extendedSavings} (${extendedSavingsPercent}%)`;

                const compactSavings = originalSize - compactSize;
                const compactSavingsPercent = ((compactSavings / originalSize) * 100).toFixed(1);
                document.getElementById('compactCharCount').innerHTML = `Characters: ${compactSize} | Savings: ${compactSavings} (${compactSavingsPercent}%)`;
            } else {
                document.getElementById('extendedCharCount').innerHTML = '';
                document.getElementById('compactCharCount').innerHTML = '';
            }
        }

        function renderDiscordItems(items, plain, prefix) {
            let text = '';
            const specialItems = items.filter(item => item.type === 'special');
            const wargearItems = items.filter(item => item.type !== 'special' && item.nameshort !== "NULL");

            if (wargearItems.length > 0) {
                wargearItems.sort((a, b) => parseInt(b.quantity.replace('x', ''), 10) - parseInt(a.quantity.replace('x', ''), 10));
                const wargearStrings = wargearItems.map(item => {
                    const itemNumericQty = parseInt(item.quantity.replace('x', ''), 10);
                    const itemQtyDisplay = itemNumericQty > 1 ? `${itemNumericQty} ` : '';
                    return `${itemQtyDisplay}${item.nameshort}`;
                });
                text += `${prefix}${wargearStrings.join(', ')}\n`;
            }

            if (specialItems.length > 0) {
                specialItems.forEach(item => {
                    text += `${prefix}${item.nameshort}\n`;
                });
            }
            return text;
        }

        function generateDiscordText(data, plain) {
            const factionKeyword = data.SUMMARY?.FACTION_KEYWORD || '';
            let text = plain ? '' : '```ansi\n';

            if (data.SUMMARY) {
                const summaryParts = [];
                if (data.SUMMARY.FACTION_KEYWORD) {
                    const faction = (data.SUMMARY.FACTION_KEYWORD.split(' - ').pop() || data.SUMMARY.FACTION_KEYWORD);
                    summaryParts.push(faction);
                                }
                if (data.SUMMARY.DETACHMENT) summaryParts.push(data.SUMMARY.DETACHMENT);
                if (data.SUMMARY.TOTAL_ARMY_POINTS) summaryParts.push(data.SUMMARY.TOTAL_ARMY_POINTS);
                if (summaryParts.length > 0) {
                    const header = summaryParts.join(' | ');
                    text += plain ? `${header}\n` : `\u001b[1;33m${header}\u001b[0m\n\n`;
                }
            }
            let firstUnitOverall = true;
            for (const section in data) {
                if (section === 'SUMMARY' || !Array.isArray(data[section])) continue;
                data[section].forEach(unit => {
                    const numericQuantity = parseInt(unit.quantity.replace('x', ''), 10);
                    const quantityDisplay = numericQuantity > 1 ? `${numericQuantity} ` : '';
                    const unitName = `${quantityDisplay}${unit.name}`;
                    const points = `${unit.points}`;
                    text += plain ? `* ${unitName} [${points}]\n` : `\u001b[0;31m* ${unitName}\u001b[0m [\u001b[0;33m${points}\u001b[0m]\n`;
                    if (unit.items && unit.items.length > 0) {
                        const hasVisibleItems = plain || unit.items.some(item => {
                            if (item.points !== undefined) {
                                return item.items && item.items.some(subItem => subItem.nameshort !== "NULL" || subItem.type === 'special');
                            }
                            return item.nameshort !== "NULL" || item.type === 'special';
                        });

                        if (hasVisibleItems) {
                            const allItems = [...unit.items];
                            const topLevelItems = allItems.filter(item => item.points === undefined);
                            const subunitItems = allItems.filter(item => item.points !== undefined).sort((a, b) => parseInt(a.quantity.replace('x', ''), 10) - parseInt(b.quantity.replace('x', ''), 10));

                            text += renderDiscordItems(topLevelItems, plain, '  - ');

                            subunitItems.forEach(item => {
                                const subUnitHasVisibleItems = plain || (item.items && item.items.some(subItem => subItem.nameshort !== "NULL" || subItem.type === 'special'));
                                if (subUnitHasVisibleItems) {
                                    const itemNumericQty = parseInt(item.quantity.replace('x', ''), 10);
                                    const itemQtyDisplay = itemNumericQty > 1 ? `${itemNumericQty} ` : '';
                                    const subunitName = item.name;
                                    text += plain ? `  + ${itemQtyDisplay}${subunitName}\n` : `  \u001b[1;36m+ ${itemQtyDisplay}${subunitName}\u001b[0m\n`;

                                    text += renderDiscordItems(item.items, plain, '    - ');
                                }
                            });
                        }
                    }
                    firstUnitOverall = false;
                });
            }
            if (!plain) text += '```';
            return text;
        }
        
        function applyTheme(factionKeyword) {
            const root = document.documentElement;
            const mainFaction = factionKeyword ? (factionKeyword.split(' - ').pop() || factionKeyword) : null;
            const theme = factionThemes[mainFaction];
            const defaultTheme = {
                "--color-bg": "#1f2937",
                "--color-surface": "#374151",
                "--color-action": "#4b5563",
                "--color-action-hover": "#6b7280"
            };
            const colorsToSet = theme || defaultTheme;
            for (const [key, value] of Object.entries(colorsToSet)) {
                root.style.setProperty(key, value);
            }
        }

        async function copyTextToClipboard(text, button) {
            if (!text) return;
            if (!navigator.clipboard) {
                console.error('Clipboard API not available');
                return;
            }
            try {
                await navigator.clipboard.writeText(text);
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.classList.add('btn-copied');
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('btn-copied');
                }, 2000);
            } catch (err) {
                console.error('Failed to copy text: ', err);
            }
        }

        document.getElementById('copyExtendedButton').addEventListener('click', () => {
             copyTextToClipboard(extendedPlainText.trim(), document.getElementById('copyExtendedButton'));
        });

        document.getElementById('copyCompactButton').addEventListener('click', () => {
            if (parsedData) {
                const textToCopy = generateDiscordText(parsedData, false);
                copyTextToClipboard(textToCopy, document.getElementById('copyCompactButton'));
            }
        });

        document.getElementById('copyPlainDiscordButton').addEventListener('click', () => {
            if (parsedData) {
                const textToCopy = generateDiscordText(parsedData, true);
                copyTextToClipboard(textToCopy.trim(), document.getElementById('copyPlainDiscordButton'));
            }
        });
    </script>

</body>
</html>