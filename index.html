<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warhammer 40k List Compactor</title>
    <link rel="stylesheet" href="styles.css?v=0.0.7">
</head>
<body>

    <div class="container">
        <div class="card">
            <header class="header">
                <h1>Warhammer 40k List Compactor</h1>
                <p>Paste your army list below (supports GW App and WTC-Compact formats). The tool will generate an extended version and a compact version. Use the "Copy for Discord" buttons for various colored, pre-formatted outputs ready for pasting.</p>
            </header>

            <!-- App Footer with Contact Info -->
            <footer class="app-footer">
                <p>For feedback or questions, reach out to <a href="https://discord.com/users/Desjani" target="_blank">@Desjani</a> on Discord.</p>
            </footer>

            <div class="grid-container">
                <!-- Input Column -->
                <div>
                    <label for="inputText" class="io-label">Paste List here (GW App or WTC-Compact)</label>
                    <textarea id="inputText" class="io-box" autofocus></textarea>
                    <div class="column-footer" style="flex-direction: column; align-items: center;">
                        <div class="button-group">
                            <button id="resetButton" class="btn btn-danger">Start Over</button>
                            <button id="parseButton" class="btn btn-primary">Compact this list</button>
                        </div>
                        <div id="inputCharCount" class="char-count" style="margin-top: 0.5rem;"></div>
                    </div>
                </div>

                <!-- Extended Output Column -->
                <div>
                    <label for="unabbreviatedOutput" class="io-label">Extended List</label>
                    <div id="unabbreviatedOutput" class="io-box"></div>
                     <div class="column-footer" style="flex-direction: column; align-items: center;">
                        <button id="copyExtendedButton" class="btn btn-copy">Copy Extended Version</button>
                        <div id="extendedCharCount" class="char-count" style="margin-top: 0.5rem;"></div>
                    </div>
                </div>

                <!-- Compacted Output Column -->
                <div>
                    <label for="compactedOutput" class="io-label">Compact List</label>
                    <div id="compactedOutput" class="io-box"></div>
                    <div class="column-footer" style="flex-direction: column; align-items: center;">
                        <div class="button-group">
                             <button id="copyCompactButton" class="btn btn-discord">Copy for Discord (Fancy)</button>
                         <button id="copyExtendedDiscordButton" class="btn btn-secondary" style="background-color: #4a56c4; border-color: #4a56c4;">Copy for Discord (Extended)</button>
                         <button id="copyPlainDiscordButton" class="btn btn-secondary" style="background-color: #495057; border-color: #495057;">Copy for Discord (Plain)</button>
                        </div>
                        <div id="compactCharCount" class="char-count" style="margin-top: 0.5rem;"></div>
                    </div>
                    <!-- Color Options Section -->
                    <div class="color-options-container" style="margin-top: 1rem; text-align: center;">
                        <div class="color-options">
                            <label><input type="radio" name="colorMode" value="none" checked> No Color</label>
                            <label><input type="radio" name="colorMode" value="custom"> Custom Colors</label>
                        </div>
                        <div id="customColorPickers" style="display: none; margin-top: 0.5rem; text-align: center;">
                            <div style="margin-bottom: 0.5rem;">
                                <label>Unit: 
                                    <select id="unitColor">
                                        <option value="#FFFFFF" selected>White</option>
                                        <option value="#808080">Grey</option>
                                        <option value="#FF0000">Red</option>
                                        <option value="#00FF00">Green</option>
                                        <option value="#FFFF00">Yellow</option>
                                        <option value="#0000FF">Blue</option>
                                        <option value="#FF00FF">Magenta</option>
                                        <option value="#00FFFF">Cyan</option>
                                    </select>
                                </label>
                            </div>
                            <div style="margin-bottom: 0.5rem;">
                                <label>Subunit: 
                                    <select id="subunitColor">
                                        <option value="#FFFFFF">White</option>
                                        <option value="#808080" selected>Grey</option>
                                        <option value="#FF0000">Red</option>
                                        <option value="#00FF00">Green</option>
                                        <option value="#FFFF00">Yellow</option>
                                        <option value="#0000FF">Blue</option>
                                        <option value="#FF00FF">Magenta</option>
                                        <option value="#00FFFF">Cyan</option>
                                    </select>
                                </label>
                            </div>
                            <div>
                                <label>Points/Header: 
                                    <select id="pointsColor">
                                        <option value="#FFFFFF">White</option>
                                        <option value="#808080">Grey</option>
                                        <option value="#FF0000">Red</option>
                                        <option value="#00FF00">Green</option>
                                        <option value="#FFFF00" selected>Yellow</option>
                                        <option value="#0000FF">Blue</option>
                                        <option value="#FF00FF">Magenta</option>
                                        <option value="#00FFFF">Cyan</option>
                                    </select>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Changelog and Roadmap Section -->
            <div class="changelog-section">
                <div class="changelog-entry roadmap">
                    <h4>Roadmap</h4>
                    <ul>
                        <li>.ROSZ file format support</li>
                        <li>Mobile-friendly version</li>
                        <li>Individual faction abbreviation rule adjustments</li>
                        <li>Ongoing bugfixes and performance improvements</li>
                    </ul>
                </div>
                <div class="changelog-entry">
                    <h4>Changelog</h4>
                    <div class="changelog-version-entry">
                        <h5>Version 0.0.4: Colors and Indentations!</h5>
                        <p>Added color customization for Discord outputs. Improved indentation and bullet points for plain text exports to render correctly in Discord.</p>
                    </div>
                    <div class="changelog-version-entry">
                        <h5>Version 0.0.3: Fixes, Formatting, and more!</h5>
                        <p>Implemented a new inline compact format for easier reading. Added more 'Copy for Discord' options for greater flexibility. Numerous parser fixes for both GW App and WTC-Compact formats to improve reliability.</p>
                    </div>
                    <div class="changelog-version-entry">
                        <h5>Version 0.0.2: Support for GW App and WTC-Compact formats</h5>
                        <p>The parser now supports both major list formats, with improved reliability for complex nested units and wargear. Abbreviation logic is now consistent across both formats.</p>
                    </div>
                    <div class="changelog-version-entry">
                        <h5>Version 0.0.1: Initial Beta Release</h5>
                        <p>The first version is live! Basic list parsing and abbreviation for most major factions is included. More features and polish to come.</p>
                    </div>
                </div>
            </div>

            <!-- Debug Toggle and Output Section -->
            <div style="text-align: center; margin-top: 1.5rem;">
                <button id="toggleDebugButton" class="btn" style="background-color: black; color: white; border: 1px solid #444;">Show Debug Log</button>
            </div>

            <div id="debugContainer" class="changelog-section" style="margin-top: 0.5rem; display: none;">
                <div class="changelog-entry">
                    <h4>Debug Log</h4>
                    <div id="debugOutput" class="io-box" style="max-height: 200px; overflow-y: auto; background-color: #282c34; color: #abb2bf; font-family: monospace; font-size: 0.75rem; line-height: 1.4;"></div>
                </div>
            </div>

        </div>
    </div>

    <script>
        // Store the parsed data globally within the script's scope
        let parsedData = null;
        let extendedPlainText = '';
        let compactPlainText = '';

        // --- Abbreviation Database ---
        let factionAbbreviationDBs = {}; // Use let to allow reassignment

        document.addEventListener('DOMContentLoaded', () => {
            const parseButton = document.getElementById('parseButton');
            parseButton.disabled = true;
            parseButton.textContent = 'Loading DB...';

            fetch('./Wargear_tree.json?v=0.0.7')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    factionAbbreviationDBs = data;
                    console.log("Wargear database loaded successfully.");
                    parseButton.disabled = false;
                    parseButton.textContent = 'Compact this list';
                })
                .catch(error => {
                    console.error("Could not load wargear database:", error);
                    parseButton.textContent = 'Error: DB Load Failed';
                });
            
            document.querySelectorAll('input[name="colorMode"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    const customPickers = document.getElementById('customColorPickers');
                    if (e.target.value === 'custom') {
                        customPickers.style.display = 'block';
                    } else {
                        customPickers.style.display = 'none';
                    }
                });
            });
        })

        function normalizeForComparison(name) {
            if (!name) return '';
            // Decomposes accented chars (e.g., 'â' -> 'a' + '^') and removes the diacritics.
            // Also handles lowercase, trim, and common character variations.
            return name.normalize("NFD").replace(/[\u0300-\u036f]/g, "")
                .toLowerCase()
                .replace(/’/g, "'")
                .trim();
        }

        function flexibleItemMatch(rule, itemName) {
            const ruleItemNormalized = normalizeForComparison(rule.item);
            const itemNameNormalized = normalizeForComparison(itemName);
            if (ruleItemNormalized === itemNameNormalized) return true; // Exact match
            if (ruleItemNormalized === itemNameNormalized + 's') return true; // input: cutter, rule: cutters
            if (itemNameNormalized.endsWith('s') && ruleItemNormalized === itemNameNormalized.slice(0, -1)) return true; // input: cutters, rule: cutter
            return false;
        }

        function abbreviate(itemName, unitName, fullFactionKeyword) {
             const debugOutput = document.getElementById('debugOutput');
             const searchOrder = [];
             const mainFaction = fullFactionKeyword ? (fullFactionKeyword.split(' - ').pop() || fullFactionKeyword) : null;

             if (mainFaction) {
                 searchOrder.push(mainFaction);
             }
             // Add broader categories for cross-faction rules.
             const spaceMarineChapters = [
                "Black Templars", "Blood Angels", "Dark Angels", "Deathwatch", 
                "Imperial Fists", "Iron Hands", "Raven Guard", "Salamanders", 
                "Space Wolves", "Ultramarines"
             ];
             const isSpaceMarineFaction = mainFaction && (
                 spaceMarineChapters.includes(mainFaction) || 
                 (fullFactionKeyword && (fullFactionKeyword.includes("Space Marines") || fullFactionKeyword.includes("Adeptus Astartes")))
             );

             if (isSpaceMarineFaction) {
                 searchOrder.push("Space Marines", "Imperial Knights", "Imperial Agents");
             } else if (fullFactionKeyword && fullFactionKeyword.includes("Imperium")) {
                 // For other non-SM Imperium factions
                 searchOrder.push("Imperial Knights", "Agents of the Imperium");
             }

            const chaosFactions = [
                "Chaos Daemons", "Chaos Knights", "Chaos Space Marines", 
                "Death Guard", "Emperor's Children", "Thousand Sons", "World Eaters"
            ];

            const isChaosFaction = mainFaction && (
                chaosFactions.includes(mainFaction) ||
                (fullFactionKeyword && fullFactionKeyword.includes("Chaos"))
            );

            if (isChaosFaction) {                 
                searchOrder.push("Chaos Space Marines", "Chaos Knights", "Chaos Daemons");
            }
             
             // --- Aeldari Factions ---
             const aeldariFactions = ["Aeldari", "Drukhari"];
             const isAeldariFaction = mainFaction && (
                 aeldariFactions.includes(mainFaction) ||
                 (fullFactionKeyword && (fullFactionKeyword.includes("Aeldari") || fullFactionKeyword.includes("Drukhari")))
             );
             if (isAeldariFaction) {
                 searchOrder.push("Aeldari", "Drukhari");
             }
             
             // --- Tyranid Factions ---
             const tyranidFactions = ["Tyranids", "Genestealer Cults"];
             const isTyranidFaction = mainFaction && (
                 tyranidFactions.includes(mainFaction) ||
                 (fullFactionKeyword && (fullFactionKeyword.includes("Tyranids") || fullFactionKeyword.includes("Genestealer Cults")))
             );
             if (isTyranidFaction) {
                searchOrder.push("Genestealer Cults", "Tyranids");
             }
             const factionsToSearch = [...new Set(searchOrder)];


             const findRule = () => {
                 let bestUnitRules = null;
                 // --- First Pass: Find the most specific unit entry across all relevant factions ---
                 for (const faction of factionsToSearch) {
                    const dbFactionKey = Object.keys(factionAbbreviationDBs).find(key => normalizeForComparison(key) === normalizeForComparison(faction));
                    if (!dbFactionKey) continue;
                    const rules = factionAbbreviationDBs[dbFactionKey];

                    const unitRulesKey = Object.keys(rules).find(key => normalizeForComparison(key) === normalizeForComparison(unitName));
                    if (unitRulesKey) {
                        bestUnitRules = rules[unitRulesKey];
                        break; // Found the first, most specific unit entry. Stop searching for the unit.
                    }
                 }

                 // --- Second Pass: Search for the item within the found unit entry. ---
                 if (bestUnitRules) {
                     let foundRule = bestUnitRules.find(rule => flexibleItemMatch(rule, itemName));
                     if (foundRule) return foundRule; // Specific item in specific unit
                     foundRule = bestUnitRules.find(rule => rule.item === "*");
                     if (foundRule) return foundRule; // Wildcard in specific unit
                 }

                 // --- Third Pass: If no unit-specific rule was found, check for global item matches ---
                 for (const faction of factionsToSearch) {
                     const dbFactionKey = Object.keys(factionAbbreviationDBs).find(key => normalizeForComparison(key) === normalizeForComparison(faction));
                     if (!dbFactionKey) continue;
                     const rules = factionAbbreviationDBs[dbFactionKey];

                     if (!rules || !rules["*"]) continue;
                     let foundRule = rules["*"].find(rule => flexibleItemMatch(rule, itemName));
                     if (foundRule) return foundRule;
                 }
                 return null;
             };

             const rule = findRule();

             return rule ? rule.abbr : itemName;
        }

        // --- Main Parsing Controller ---
        document.getElementById('parseButton').addEventListener('click', () => {
            const debugOutput = document.getElementById('debugOutput');
            if (debugOutput) debugOutput.innerHTML = '';
            const text = document.getElementById('inputText').value;
            const lines = text.split('\n');

            const format = detectFormat(lines);
            const parser = parsers[format];

            if (!parser) {
                console.error("Unsupported list format.");
                document.getElementById('unabbreviatedOutput').innerHTML = '<p style="color: var(--color-danger);">Unsupported list format. Please use GW App or WTC-Compact format.</p>';
                document.getElementById('compactedOutput').innerHTML = '';
                return;
            }

            const result = parser(lines);

            // --- Debug Parsed Object ---
            if (debugOutput) {
                const resultEntry = document.createElement('pre');
                resultEntry.style.whiteSpace = 'pre-wrap';
                resultEntry.style.wordBreak = 'break-all';
                resultEntry.textContent = JSON.stringify(result, null, 2);
                debugOutput.appendChild(resultEntry);
            }

            // --- Common Rendering Logic ---
            parsedData = result;
            const extendedOutput = generateOutput(result, false);
            document.getElementById('unabbreviatedOutput').innerHTML = extendedOutput.html;
            extendedPlainText = extendedOutput.plainText;
            const compactOutput = generateOutput(result, true);
            document.getElementById('compactedOutput').innerHTML = compactOutput.html;
            compactPlainText = compactOutput.plainText;
            updateCharCounts();
        });

        document.getElementById('resetButton').addEventListener('click', () => {
            document.getElementById('inputText').value = '';
            document.getElementById('unabbreviatedOutput').innerHTML = '';
            document.getElementById('compactedOutput').innerHTML = '';
            document.getElementById('debugOutput').innerHTML = '';

            parsedData = null;
            extendedPlainText = '';
            compactPlainText = '';

            updateCharCounts();
            document.getElementById('inputText').focus();
        });

        document.getElementById('toggleDebugButton').addEventListener('click', (e) => {
            const debugContainer = document.getElementById('debugContainer');
            const button = e.currentTarget;
            if (debugContainer.style.display === 'none') {
                debugContainer.style.display = 'flex';
                button.textContent = 'Hide Debug Log';
            } else {
                debugContainer.style.display = 'none';
                button.textContent = 'Show Debug Log';
            }
        });

        // --- Helper Functions (shared by parsers) ---
        function getIndent(s) { return s.match(/^\s*/)[0].length; }

        function addItemToTarget(target, itemString, unitContextName, factionKeyword, itemType = 'wargear') {
            if (!target || !itemString) return;

            const cleanItemNameForCheck = itemString.replace(/^\d+x?\s*/, '').trim();
            if (normalizeForComparison(cleanItemNameForCheck) === 'warlord') {
                itemType = 'special';
            }

            const withMatch = itemString.match(/(\d+)\s+with\s+(.*)/);
            if (withMatch) {
                const quantity = parseInt(withMatch[1]);
                const items = withMatch[2].split(',').map(s => s.trim());
                items.forEach(itemName => {
                    if (normalizeForComparison(itemName) === normalizeForComparison(unitContextName)) {
                        return; // It's a redundant unit name, so ignore it.
                    }
                    const { quantity: innerQuantity, name } = parseItemString(itemName);
                    const numericInnerQuantity = parseInt(innerQuantity.replace('x', ''), 10) || 1;
                    const totalQuantity = quantity * numericInnerQuantity;
                    const nameshort = abbreviate(name, unitContextName, factionKeyword);
                    const existingItem = target.items.find(item => item.name === name);
                    if (existingItem) {
                        const existingQty = parseInt(existingItem.quantity.replace('x', ''));
                        existingItem.quantity = `${existingQty + totalQuantity}x`;
                    } else {
                        target.items.push({ quantity: `${totalQuantity}x`, name, nameshort, items: [], type: itemType });
                    }
                });
                return;
            }
            const { quantity, name } = parseItemString(itemString);
            if (normalizeForComparison(name) === normalizeForComparison(unitContextName)) {
                return; // It's a redundant unit name, so ignore it.
            }
            const nameshort = itemType === 'special' ? name : abbreviate(name, unitContextName, factionKeyword);
            const numericQuantity = parseInt(quantity.replace('x', ''), 10);
            const existingItem = target.items.find(item => item.name === name);
            if (existingItem) {
                const existingQty = parseInt(existingItem.quantity.replace('x', ''));
                existingItem.quantity = `${existingQty + numericQuantity}x`;
            } else {
                target.items.push({ quantity, name, nameshort, items: [], type: itemType });
            }
        };

        function parseAndAddEnhancement(enhancementContent, targetUnit, factionKeyword) {
            if (!targetUnit) return;
            const pointsRegex = /\s*\((.*?)\)$/;
            const pointsMatch = enhancementContent.match(pointsRegex);
            
            let enhancementName = enhancementContent;
            let enhancementPoints = '';

            if (pointsMatch) {
                enhancementName = enhancementContent.replace(pointsRegex, '').trim();
                const pointsText = pointsMatch[1].replace(/\s*pts/i, '');
                enhancementPoints = `(${pointsText})`;
            }

            // Prevent duplicate enhancements if the list is redundant (e.g., in header and body)
            const alreadyExists = targetUnit.items.some(item =>
                item.type === 'special' &&
                normalizeForComparison(item.name).includes(normalizeForComparison(enhancementName))
            );
            if (alreadyExists) {
                return;
            }

            const abbreviation = enhancementName.split(/[\s-]+/).map(word => word.charAt(0)).join('').toUpperCase();
            const shortText = `E: ${abbreviation} ${enhancementPoints}`.trim();
            
            targetUnit.items.push({ quantity: '1x', name: `Enhancement: ${enhancementContent}`, nameshort: shortText, items: [], type: 'special' });
        };

        // --- Format Detector ---
        function detectFormat(lines) {
            // WTC check is more specific, so it should go first.
            if (lines.slice(0, 10).some(line => /^\s*\+\s*FACTION KEYWORD:/.test(line))) {
                return 'WTC_COMPACT';
            }
            // GW App check is broader. Check for common section headers like CHARACTERS or BATTLELINE.
            if (lines.slice(0, 25).some(line => /^\s*(CHARACTERS|BATTLELINE|OTHER DATASHEETS|ALLIED UNITS)\s*$/.test(line.toUpperCase()))) {
                return 'GW_APP';
            }
            return 'UNKNOWN';
        }

        // --- Parser Registration ---
        const parsers = {
            GW_APP: parseGwApp,
            WTC_COMPACT: parseWtcCompact
        };

        // --- GW App Parser ---
        function parseGwApp(lines) {
            const result = {};
            let currentSection = null;
            let factionKeyword = null;
            const contextStack = []; // [{ indent, node }]

            // --- Header Parsing ---
            result.SUMMARY = {};
            const firstLine = lines[0];
            const pointsMatch = firstLine.match(/\((\d+)\s*points\)/);
            if (pointsMatch) {
                result.SUMMARY.TOTAL_ARMY_POINTS = `${pointsMatch[1]}pts`;
            }
            const detachmentIndex = lines.findIndex(line => /(Combat Patrol|Incursion|Strike Force|Onslaught)/.test(line));
            if (detachmentIndex !== -1 && detachmentIndex + 1 < lines.length) {
                const nextLine = lines[detachmentIndex + 1].trim();
                if (nextLine && !/^(CHARACTERS|BATTLELINE|OTHER DATASHEETS|ALLIED UNITS)$/.test(nextLine.toUpperCase())) {
                    result.SUMMARY.DETACHMENT = nextLine;
                }
                const factionLines = lines.slice(1, detachmentIndex).map(l => l.trim()).filter(l => l);
                if (factionLines.length > 0) {
                    const fullFaction = factionLines.join(' - ');
                    const shortFaction = factionLines[factionLines.length - 1];
                    result.SUMMARY.FACTION_KEYWORD = shortFaction; // For debug display matching user expectation
                    result.SUMMARY.DISPLAY_FACTION = fullFaction; // For list header display
                    factionKeyword = fullFaction; // For internal logic (abbreviation)
                }
            }
            if (!result.SUMMARY.TOTAL_ARMY_POINTS && detachmentIndex !== -1) {
                const gameSizeMatch = lines[detachmentIndex].match(/\((\d+)\s*points\)/);
                if (gameSizeMatch) {
                    result.SUMMARY.TOTAL_ARMY_POINTS = `${gameSizeMatch[1]}pts`;
                }
            }

            // --- Regex Definitions ---
            const sectionHeaderRegex = /^(CHARACTERS|CHARACTER|BATTLELINE|OTHER DATASHEETS|ALLIED UNITS|DEDICATED TRANSPORTS)$/;
            const gwUnitRegex = /^(.*?)\s+\((\d+)\s+(?:pts|points)\)$/;
            const bulletItemRegex = /^\s*•\s*(.*)/;

            let listParsingStarted = false;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();
                if (!trimmedLine || trimmedLine.startsWith('Exported with')) continue;

                // Section headers are the trigger to start parsing the list content.
                if (sectionHeaderRegex.test(trimmedLine.toUpperCase())) {
                    listParsingStarted = true;
                    currentSection = trimmedLine.toUpperCase().replace('CHARACTER', 'CHARACTERS').replace('DEDICATED TRANSPORTS', 'OTHER DATASHEETS');
                    contextStack.length = 0;
                    continue;
                }

                if (!listParsingStarted) {
                    continue; // Ignore everything before the first section header.
                }

                // --- From here on, we are parsing the actual list ---
                const indent = getIndent(line);
                while (contextStack.length > 0 && indent <= contextStack[contextStack.length - 1].indent) {
                    contextStack.pop();
                }
                const parentContext = contextStack.length > 0 ? contextStack[contextStack.length - 1] : null;

                // Unit Detection (must not be indented)
                if (indent === 0) {
                    const gwMatch = trimmedLine.match(gwUnitRegex);
                    if (gwMatch) {
                        const unitName = gwMatch[1].trim();
                        const unitPoints = parseInt(gwMatch[2]);
                        const newUnit = { quantity: '1x', name: unitName, points: unitPoints, items: [] };
                        
                        const sectionKey = currentSection || 'OTHER DATASHEETS';
                        result[sectionKey] = result[sectionKey] || [];
                        result[sectionKey].push(newUnit);

                        contextStack.push({ indent, node: newUnit });
                        continue;
                    }
                }

                // Item / Sub-unit Parsing (must be under a unit)
                if (parentContext) {
                    const bulletMatch = trimmedLine.match(bulletItemRegex);
                    if (bulletMatch) {
                        const itemContent = bulletMatch[1].trim();
                        const topLevelUnitName = contextStack[0].node.name;
                        
                        if (itemContent.startsWith('Enhancement:')) {
                            parseAndAddEnhancement(itemContent.replace('Enhancement:', '').trim(), contextStack[0].node, factionKeyword);
                            continue;
                        }

                        const subUnitRegex = /^(\d+x?\s+)(.*)/;
                        const subUnitMatch = itemContent.match(subUnitRegex);
                        const nextLine = (i + 1 < lines.length) ? lines[i + 1] : '';
                        const nextLineIsMoreIndented = nextLine.trim() !== '' && getIndent(nextLine) > getIndent(line);
                        const nextLineIsBulleted = nextLine.trim().startsWith('•');

                        // A bulleted line is a subunit only if it's followed by a MORE indented AND bulleted line.
                        // This is a more reliable heuristic for the GW App format.
                        if (subUnitMatch && nextLineIsMoreIndented && nextLineIsBulleted) {
                            const newSubUnit = {
                                quantity: subUnitMatch[1].trim(),
                                name: subUnitMatch[2].trim(),
                                    points: 0,
                                    items: []
                                };
                            parentContext.node.items.push(newSubUnit);
                            contextStack.push({ indent, node: newSubUnit });
                        } else {
                            addItemToTarget(parentContext.node, itemContent, topLevelUnitName, factionKeyword);
                        }
                    } else if (indent > 0) { // It's an indented, non-bulleted line (wargear)
                        const topLevelUnitName = contextStack[0].node.name;
                        addItemToTarget(parentContext.node, trimmedLine, topLevelUnitName, factionKeyword);
                    }
                }
            }

            // --- Post-processing: Calculate total quantities for units with subunits ---
            for (const section in result) {
                if (Array.isArray(result[section])) {
                    result[section].forEach(unit => {
                        // We only want to sum quantities for units that have subunits.
                        const hasSubunits = unit.items && unit.items.some(item => item.points !== undefined);

                        if (hasSubunits) {
                            let totalQuantity = 0;
                            unit.items.forEach(item => {
                                // A subunit is an item that has a 'points' property. Wargear does not.
                                if (item.points !== undefined) {
                                    totalQuantity += parseInt(item.quantity.replace('x', ''), 10) || 0;
                                }
                            });

                            if (totalQuantity > 1) {
                                unit.quantity = `${totalQuantity}x`;
                            }
                        }
                    });
                }
            }
            return result;
        }

        // --- WTC Compact Parser ---
        function parseWtcCompact(lines) {
            const result = { SUMMARY: {}, CHARACTER: [], "OTHER DATASHEETS": [] };
            let currentSection = null;
            let factionKeyword = null;
            const enhancementTargets = {};

            // --- Regex Definitions ---
            const summaryRegex = /^\+\s*([^:]+):\s*(.*)$/;
            const summaryEnhancementRegex = /^&\s*(.*)/;
            const separatorRegex = /^\s*\+{3}\s*$/;
            const sectionHeaderRegex = /^(CHARACTER|OTHER DATASHEETS)$/;
            const unitRegex = /^(?:(?<charid>Char\d+):\s*)?(?<unitinfo>.*?)\s+\((?<points>\d+)\s*pts?\)(?<wargearblock>:\s*(?<wargear>.*))?$/;
            const bulletRegex = /^\s*•\s*(.*)/;
            const enhancementLineRegex = /^Enhancement:\s*(.*)/;

            // --- Pass 1: Separate Header and Body ---
            let headerLines;
            let bodyLines;
            const separatorIndex = lines.findIndex(line => separatorRegex.test(line.trim()));

            if (separatorIndex !== -1) {
                headerLines = lines.slice(0, separatorIndex);
                bodyLines = lines.slice(separatorIndex + 1);
            } else {
                const firstBodyLineIndex = lines.findIndex(line => {
                    const trimmed = line.trim();
                    if (trimmed === '' || trimmed.startsWith('+') || trimmed.startsWith('&')) {
                        return false; // These are header lines or blank lines, not the start of the body.
                    }
                    // A true body line is a section header or a unit definition.
                    // Anything else (like a list title) is considered part of the preamble.
                    if (sectionHeaderRegex.test(trimmed) || unitRegex.test(trimmed)) {
                        return true;
                    }
                    return false;
                });

                if (firstBodyLineIndex === -1) { // No body found, all lines are header-like
                    headerLines = lines;
                    bodyLines = [];
                } else {
                    headerLines = lines.slice(0, firstBodyLineIndex);
                    bodyLines = lines.slice(firstBodyLineIndex);
                }
            }

            // --- Pass 2: Parse Header ---
            for (const line of headerLines) {
                const summaryMatch = line.match(summaryRegex);
                if (summaryMatch) {
                    const key = summaryMatch[1].trim().toUpperCase();
                    const value = summaryMatch[2].trim();
                    if (key === 'FACTION KEYWORD') {
                        const fullFaction = value;
                        const shortFaction = value.split(' - ').pop();
                        result.SUMMARY.FACTION_KEYWORD = shortFaction; // For debug display matching user expectation
                        result.SUMMARY.DISPLAY_FACTION = fullFaction; // For list header display
                        factionKeyword = fullFaction; // For internal logic (abbreviation)
                    } else if (key === 'DETACHMENT') {
                        result.SUMMARY.DETACHMENT = value;
                    } else if (key === 'TOTAL ARMY POINTS') {
                        result.SUMMARY.TOTAL_ARMY_POINTS = value;
                    }
                    continue;
                }

                const summaryEnhancementMatch = line.match(summaryEnhancementRegex);
                if (summaryEnhancementMatch) {
                    const value = summaryEnhancementMatch[1].trim();
                    const enhMatch = value.match(/(?:Enhancement:\s*)?(.*)\s\(on\s(?:(Char\d+):\s*)?(.*)\)/);
                    if (enhMatch) {
                        const enhName = enhMatch[1].trim();
                        const targetName = enhMatch[3].trim();
                        enhancementTargets[targetName] = enhName;
                    }
                }
            }

            // --- Pass 3: Parse Body ---
            const contextStack = []; // Stack of { indent: number, node: object }
            let lastUnitProcessed = null;

            for (let i = 0; i < bodyLines.length; i++) {
                const line = bodyLines[i];
                const trimmedLine = line.trim();
                if (!trimmedLine || separatorRegex.test(trimmedLine)) continue;

                const indent = getIndent(line);

                while (contextStack.length > 0) {
                    const lastContext = contextStack[contextStack.length - 1];
                    // A new context is a child if it's more indented.
                    // Or, if it's a bullet and the parent is not, at the same indent level.
                    const isChildBullet = trimmedLine.startsWith('•') && !lastContext.isBullet && indent === lastContext.indent;

                    if (indent > lastContext.indent || isChildBullet) {
                        // The current context is correct, this line is a child.
                    } else {
                        // This line is a sibling or a parent, so pop the context.
                        contextStack.pop();
                    }
                    break; // Otherwise, the context is correct
                }

                const parentContext = contextStack.length > 0 ? contextStack[contextStack.length - 1] : null;

                // Case 1: Section Header
                if (indent === 0 && sectionHeaderRegex.test(trimmedLine)) {
                    currentSection = trimmedLine;
                    contextStack.length = 0;
                    continue;
                }

                // Case 2: Unit Line (simple or complex)
                const unitMatch = trimmedLine.match(unitRegex);
                if (unitMatch && (indent === 0 || !parentContext)) {
                    const { charid, unitinfo, points, wargear } = unitMatch.groups;
                    const { quantity, name } = parseItemString(unitinfo.trim());
                    
                    const newUnit = { 
                        quantity, 
                        name, 
                        points: parseInt(points, 10), 
                        items: [],
                        isComplex: !unitMatch.groups.wargearblock
                    };

                    const sectionKey = (currentSection === 'CHARACTER' || charid) ? 'CHARACTER' : 'OTHER DATASHEETS';
                    result[sectionKey] = result[sectionKey] || [];
                    result[sectionKey].push(newUnit);
                    lastUnitProcessed = newUnit;
                    contextStack.push({ indent, node: newUnit, isBullet: trimmedLine.startsWith('•') });

                    if (wargear) {
                        wargear.split(',').forEach(item => addItemToTarget(newUnit, item.trim(), newUnit.name, factionKeyword));
                    }
                    continue;
                }

                // Case for top-level enhancements that belong to the previous unit
                const enhancementMatch = trimmedLine.match(enhancementLineRegex);
                if (enhancementMatch && !parentContext) {
                    if (lastUnitProcessed) {
                        parseAndAddEnhancement(enhancementMatch[1].trim(), lastUnitProcessed, factionKeyword);
                    }
                    continue;
                }


                // Case 3: Indented item (Sub-unit, Wargear, or Enhancement)
                if (parentContext) {
                    const topLevelUnitName = contextStack[0].node.name;
                    const bulletMatch = trimmedLine.match(bulletRegex);

                    if (bulletMatch) { // It's a potential sub-unit or bulleted wargear
                        const content = bulletMatch[1];
                        const [subUnitInfo, wargearInfo] = content.split(/:\s*/, 2);
                        const subUnitMatch = subUnitInfo.match(/^(\d+x?\s+)(.*)/);
                        const nextLine = (i + 1 < bodyLines.length) ? bodyLines[i + 1] : '';
                        const nextLineIsMoreIndented = nextLine.trim() !== '' && getIndent(nextLine) > getIndent(line);

                        // A line is a subunit if it starts with a quantity AND (it has wargear on the same line OR it's followed by an indent)
                        if (subUnitMatch && (wargearInfo || nextLineIsMoreIndented)) {
                            const { quantity, name } = parseItemString(subUnitInfo);
                            const newSubUnit = { quantity, name, points: 0, items: [] };
                            parentContext.node.items.push(newSubUnit);

                            if (wargearInfo) { // Single-line subunit (e.g. Intercessors)
                                wargearInfo.split(/(?=\d+\s+with)|,/).forEach(part => {
                                    addItemToTarget(newSubUnit, part.trim(), topLevelUnitName, factionKeyword);
                                });
                            } else { // Multi-line subunit (e.g. Jakhals), its wargear is on subsequent lines
                                contextStack.push({ indent, node: newSubUnit, isBullet: trimmedLine.startsWith('•') });
                            }
                        } else {
                            // It's a bulleted line, but not a subunit header. Treat as wargear for the current context.
                            addItemToTarget(parentContext.node, content, topLevelUnitName, factionKeyword);
                        }
                        continue; // The bulleted line is processed.
                    } else if (trimmedLine.match(enhancementLineRegex)) { // Enhancement for the top-level unit
                        const enhContent = trimmedLine.match(enhancementLineRegex)[1].trim();
                        parseAndAddEnhancement(enhContent, contextStack[0].node, factionKeyword);
                    } else { // Wargear for the current context (the last thing on the stack)
                        addItemToTarget(parentContext.node, trimmedLine, topLevelUnitName, factionKeyword);
                    }
                }
            }

            // --- Pass 4: Apply Enhancements from Header ---
            Object.keys(enhancementTargets).forEach(targetName => {
                const enhName = enhancementTargets[targetName];
                const allUnits = [...(result.CHARACTER || []), ...(result['OTHER DATASHEETS'] || [])];
                const targetUnit = allUnits.find(u => normalizeForComparison(u.name) === normalizeForComparison(targetName));
                if (targetUnit) {
                    parseAndAddEnhancement(enhName, targetUnit, factionKeyword);
                }
            });

            return result;
        }

        function parseItemString(itemString) {
            const match = itemString.match(/^(\d+x?\s+)?(.*)$/);
            if (match) {
                const quantity = match[1] ? match[1].trim() : '1x';
                const name = match[2].trim();
                return { quantity, name };
            }
            return { quantity: '1x', name: itemString };
        }

        function getInlineItemsString(items, useAbbreviations = true) {
            if (!items || items.length === 0) return '';
            
            const specialItems = items.filter(item => item.type === 'special' && item.nameshort !== "NULL");
            const wargearItems = items.filter(item => item.type === 'wargear' && item.nameshort !== "NULL");

            if (specialItems.length === 0 && wargearItems.length === 0) return '';

            wargearItems.sort((a, b) => parseInt(b.quantity.replace('x', ''), 10) - parseInt(a.quantity.replace('x', ''), 10));
            
            const specialStrings = specialItems.map(item => {
                if (useAbbreviations) {
                    return item.nameshort;
                }
                // For extended discord format, show the full name but clean it up.
                if (item.name.startsWith('Enhancement: ')) {
                    return item.name.substring('Enhancement: '.length);
                }
                return item.name;
            });
            const wargearStrings = wargearItems.map(item => {
                const itemNumericQty = parseInt(item.quantity.replace('x', ''), 10);
                const itemQtyDisplay = itemNumericQty > 1 ? `${itemNumericQty} ` : '';
                const itemName = useAbbreviations ? item.nameshort : item.name;
                return `${itemQtyDisplay}${itemName}`;
            });

            const allStrings = [...specialStrings, ...wargearStrings];
            
            return ` (${allStrings.join(', ')})`;
        }

        function generateOutput(data, useAbbreviations) {
            let html = '', plainText = '';
            const factionKeyword = data.SUMMARY?.FACTION_KEYWORD || '';
            const displayFaction = data.SUMMARY?.DISPLAY_FACTION || (factionKeyword.split(' - ').pop() || factionKeyword);
            if (data.SUMMARY) {
                const summaryParts = [];
                if (displayFaction) summaryParts.push(displayFaction);
                if (data.SUMMARY.DETACHMENT) summaryParts.push(`${data.SUMMARY.DETACHMENT}`);
                if (data.SUMMARY.TOTAL_ARMY_POINTS) summaryParts.push(`${data.SUMMARY.TOTAL_ARMY_POINTS}`);
                if (summaryParts.length > 0) {
                    const summaryText = summaryParts.join(' | ');
                    html += `<div style="padding-bottom: 0.5rem; border-bottom: 1px solid var(--color-border);"><p style="font-size: 0.75rem; margin-bottom: 0.25rem; color: var(--color-text-secondary); font-weight: 600;">${summaryText}</p></div>`;
                    plainText += summaryText + '\n-------------------------------------\n';
                }
            }
            html += `<div style="margin-top: 0.5rem;">`;
            for (const section in data) {
                if (section !== 'SUMMARY' && Array.isArray(data[section]) && data[section].length > 0) {
                    data[section].forEach(unit => {
                        const numericQuantity = parseInt(unit.quantity.replace('x', ''), 10);
                        let quantityDisplay = numericQuantity > 1 ? `${numericQuantity} ` : '';
                        // For complex units with subunits, the total quantity is implied, so we don't show it on the main line.
                        if (unit.isComplex) {
                            quantityDisplay = '';
                        }

                        if (useAbbreviations) {
                            const topLevelItems = unit.items.filter(item => item.points === undefined);
                            const itemsString = getInlineItemsString(topLevelItems);
                            const unitText = `${quantityDisplay}${unit.name}${itemsString} [${unit.points}]`;
                            html += `<div><p style="color: var(--color-text-primary); font-weight: 600; font-size: 0.875rem; margin-bottom: 0.25rem;">${unitText}</p>`;
                            plainText += `* ${unitText}\n`;

                            const subunitItems = unit.items.filter(item => item.points !== undefined);
                            if (subunitItems.length > 0) {
                                html += `<div style="padding-left: 1rem; font-size: 0.75rem; color: var(--color-text-secondary); font-weight: 400;">`;
                                subunitItems.forEach(item => {
                                    const subUnitHasVisibleItems = item.items && item.items.some(subItem => subItem.nameshort !== "NULL" || subItem.type === 'special');
                                    if (subUnitHasVisibleItems) {
                                        const itemNumericQty = parseInt(item.quantity.replace('x', ''), 10);
                                        const itemQtyDisplay = itemNumericQty > 1 ? `${itemNumericQty} ` : '';
                                        const subunitItemsString = getInlineItemsString(item.items);
                                        const itemText = `${itemQtyDisplay}${item.name}${subunitItemsString}`;
                                        html += `<p style="font-weight: 500; color: var(--color-text-primary); margin: 0;">${itemText}</p>`;
                                        plainText += `  + ${itemText}\n`;
                                    }
                                });
                                html += `</div>`;
                            }
                            html += `</div>`;
                        } else {
                            // Extended List (original logic)
                            const unitText = `${quantityDisplay}${unit.name} ${unit.points}`;
                            html += `<div><p style="color: var(--color-text-primary); font-weight: 600; font-size: 0.875rem; margin-bottom: 0.25rem;">${unitText}</p>`;
                            plainText += `* ${unitText}\n`;
                            if (unit.items && unit.items.length > 0) {
                                html += `<div style="padding-left: 1rem; font-size: 0.75rem; color: var(--color-text-secondary); font-weight: 400;">`;
                                const topLevelItems = unit.items.filter(item => item.points === undefined);
                                const subunitItems = unit.items.filter(item => item.points !== undefined).sort((a, b) => parseInt(a.quantity.replace('x', ''), 10) - parseInt(b.quantity.replace('x', ''), 10));

                                topLevelItems.forEach(item => {
                                    const itemNumericQty = parseInt(item.quantity.replace('x', ''), 10);
                                    const itemQtyDisplay = itemNumericQty > 1 ? `${itemNumericQty} ` : '';
                                    html += `<p style="margin: 0;">${itemQtyDisplay}${item.name}</p>`;
                                    plainText += `  - ${itemQtyDisplay}${item.name}\n`;
                                });

                                subunitItems.forEach(item => {
                                    const itemNumericQty = parseInt(item.quantity.replace('x', ''), 10);
                                    const itemQtyDisplay = itemNumericQty > 1 ? `${itemNumericQty} ` : '';
                                    const itemText = `${itemQtyDisplay}${item.name}`;
                                    html += `<p style="font-weight: 500; color: var(--color-text-primary); margin: 0.5rem 0 0 0;">${itemText}</p>`;
                                    plainText += `  * ${itemText}\n`;

                                    if (item.items && item.items.length > 0) {
                                        html += `<div style="padding-left: 1rem;">`;
                                        item.items.forEach(subItem => {
                                            const subItemNumericQty = parseInt(subItem.quantity.replace('x', ''), 10);
                                            const subItemQtyDisplay = subItemNumericQty > 1 ? `${subItemNumericQty} ` : '';
                                            html += `<p style="margin: 0;">${subItemQtyDisplay}${subItem.name}</p>`;
                                            plainText += `    - ${subItemQtyDisplay}${subItem.name}\n`;
                                        });
                                        html += `</div>`;
                                    }
                                });
                                html += `</div>`;
                            }
                            html += `</div>`;
                        }
                    });
                }
            }
            html += `</div>`;
            return { html, plainText };
        }    
    function updateCharCounts() {
        const originalSize = document.getElementById('inputText').value.length;
        const extendedSize = extendedPlainText.trim().length;
        const compactSize = compactPlainText.trim().length;
        
        document.getElementById('inputCharCount').textContent = `Characters: ${originalSize}`;

        if (originalSize > 0) {
            const extendedRatioPercent = ((extendedSize / originalSize) * 100).toFixed(1);
            document.getElementById('extendedCharCount').innerHTML = `Characters: ${extendedSize} | ${extendedRatioPercent}%`;

            const compactRatioPercent = ((compactSize / originalSize) * 100).toFixed(1);
            document.getElementById('compactCharCount').innerHTML = `Characters: ${compactSize} | ${compactRatioPercent}%`;
        } else {
            document.getElementById('extendedCharCount').innerHTML = '';
            document.getElementById('compactCharCount').innerHTML = '';
        }
    }

        function generateDiscordText(data, plain, useAbbreviations = true) {
            const colorMode = document.querySelector('input[name="colorMode"]:checked').value;
            const useColor = !plain && colorMode !== 'none';
            let text = plain ? '' : (useColor ? '```ansi\n' : '```\n');

            const ansiPalette = [
                { name: 'grey', hex: '#808080', code: 30 },
                { name: 'red', hex: '#FF0000', code: 31 },
                { name: 'green', hex: '#00FF00', code: 32 },
                { name: 'yellow', hex: '#FFFF00', code: 33 },
                { name: 'blue', hex: '#0000FF', code: 34 },
                { name: 'magenta', hex: '#FF00FF', code: 35 },
                { name: 'cyan', hex: '#00FFFF', code: 36 },
                { name: 'white', hex: '#FFFFFF', code: 37 }
            ];

            const hexToRgb = (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
            };

            const findClosestAnsi = (hexColor) => {
                const inputRgb = hexToRgb(hexColor);
                if (!inputRgb) return ansiPalette.find(c => c.name === 'white').code;

                let minDistance = Infinity;
                let bestCode = ansiPalette.find(c => c.name === 'white').code;

                for (const color of ansiPalette) {
                    const paletteRgb = hexToRgb(color.hex);
                    const distance = Math.pow(inputRgb.r - paletteRgb.r, 2) +
                                   Math.pow(inputRgb.g - paletteRgb.g, 2) +
                                   Math.pow(inputRgb.b - paletteRgb.b, 2);
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestCode = color.code;
                    }
                }
                return bestCode;
            };

            const toAnsi = (txt, hexColor, bold = false) => {
                if (!useColor || !hexColor) return txt;
                // Black is often unreadable on Discord's dark theme.
                if (hexColor.toLowerCase() === '#000000') return txt;

                const ansiCode = findClosestAnsi(hexColor);
                const boldCode = bold ? '1;' : '';
                return `\u001b[${boldCode}${ansiCode}m${txt}\u001b[0m`;
            };

            let colors = { unit: '#FFFFFF', subunit: '#808080', points: '#FFFF00' }; // Default custom colors
            if (useColor) {
                if (colorMode === 'custom') {
                    colors = {
                        unit: document.getElementById('unitColor').value,
                        subunit: document.getElementById('subunitColor').value,
                        points: document.getElementById('pointsColor').value
                    };
                }
            }

            if (data.SUMMARY) {
                const summaryParts = [];
                if (data.SUMMARY.FACTION_KEYWORD) {
                    const displayFaction = data.SUMMARY?.DISPLAY_FACTION || (data.SUMMARY.FACTION_KEYWORD.split(' - ').pop() || data.SUMMARY.FACTION_KEYWORD);
                    summaryParts.push(displayFaction);
                }
                if (data.SUMMARY.DETACHMENT) summaryParts.push(data.SUMMARY.DETACHMENT);
                if (data.SUMMARY.TOTAL_ARMY_POINTS) summaryParts.push(data.SUMMARY.TOTAL_ARMY_POINTS);
                if (summaryParts.length > 0) {
                    const header = summaryParts.join(' | ');
                    text += `${toAnsi(header, colors.points, true)}\n\n`;
                }
            }
            for (const section in data) {
                if (section === 'SUMMARY' || !Array.isArray(data[section])) continue;
                data[section].forEach(unit => {
                    const numericQuantity = parseInt(unit.quantity.replace('x', ''), 10);
                    let quantityDisplay = numericQuantity > 1 ? `${numericQuantity} ` : '';
                    if (unit.isComplex) {
                        quantityDisplay = '';
                    }
                    const unitName = `${quantityDisplay}${unit.name}`;
                    const points = `${unit.points}`;
                    const topLevelItems = unit.items.filter(item => item.points === undefined);
                    const itemsString = getInlineItemsString(topLevelItems, useAbbreviations);
                    text += `* ${toAnsi(unitName, colors.unit, true)}${itemsString} ${toAnsi(`[${points}]`, colors.points, true)}\n`;
                    
                    const subunitItems = unit.items.filter(item => item.points !== undefined);
                    subunitItems.forEach(item => {
                        const subUnitHasVisibleItems = item.items && item.items.some(subItem => subItem.nameshort !== "NULL" || subItem.type === 'special');
                        if (subUnitHasVisibleItems) {
                            const itemNumericQty = parseInt(item.quantity.replace('x', ''), 10);
                            const itemQtyDisplay = itemNumericQty > 1 ? `${itemNumericQty} ` : '';
                            const subunitName = item.name;
                            const subunitItemsString = getInlineItemsString(item.items, useAbbreviations);
                            const subunitText = `${itemQtyDisplay}${subunitName}`;
                            const prefix = plain ? '*' : '+';
                            text += `  ${prefix} ${toAnsi(subunitText, colors.subunit)}${subunitItemsString}\n`;
                        }
                    });
                });
            }
            if (!plain) text += '```';
            return text;
        }

        async function copyTextToClipboard(text, button) {
            if (!text) return;
            if (!navigator.clipboard) {
                console.error('Clipboard API not available');
                return;
            }
            try {
                await navigator.clipboard.writeText(text);
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.classList.add('btn-copied');
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('btn-copied');
                }, 2000);
            } catch (err) {
                console.error('Failed to copy text: ', err);
            }
        }

        document.getElementById('copyExtendedButton').addEventListener('click', () => {
             copyTextToClipboard(extendedPlainText.trim(), document.getElementById('copyExtendedButton'));
        });

        document.getElementById('copyCompactButton').addEventListener('click', () => {
            if (parsedData) {
                const textToCopy = generateDiscordText(parsedData, false, true);
                copyTextToClipboard(textToCopy, document.getElementById('copyCompactButton'));
            }
        });

        document.getElementById('copyExtendedDiscordButton').addEventListener('click', () => {
            if (parsedData) {
                const textToCopy = generateDiscordText(parsedData, false, false);
                copyTextToClipboard(textToCopy, document.getElementById('copyExtendedDiscordButton'));
            }
        });

        document.getElementById('copyPlainDiscordButton').addEventListener('click', () => {
            if (parsedData) {
                const textToCopy = generateDiscordText(parsedData, true);
                copyTextToClipboard(textToCopy.trim(), document.getElementById('copyPlainDiscordButton'));
            }
        });
    </script>

</body>
</html>