<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warhammer List Compactor</title>
    <style>
        /* --- General Styles & Resets --- */
        :root {
            --color-bg: #111827; /* gray-900 */
            --color-surface: #1f2937; /* gray-800 */
            --color-primary: #4f46e5; /* indigo-600 */
            --color-primary-hover: #4338ca; /* indigo-700 */
            --color-secondary: #16a34a; /* green-600 */
            --color-secondary-hover: #15803d; /* green-700 */
            --color-action: #2563eb; /* blue-600 */
            --color-action-hover: #1d4ed8; /* blue-700 */
            --color-text-primary: #d1d5db; /* gray-300 */
            --color-text-secondary: #9ca3af; /* gray-400 */
            --color-text-muted: #6b7280; /* gray-500 */
            --color-border: #4b5563; /* gray-600 */
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--color-bg);
            color: var(--color-text-primary);
            margin: 0;
            padding: 1rem;
        }

        /* --- Scrollbar Styling --- */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: var(--color-surface);
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: var(--color-text-muted);
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--color-text-secondary);
        }

        /* --- Layout & Container --- */
        .container {
            max-width: 1280px;
            margin-left: auto;
            margin-right: auto;
        }

        .card {
            background-color: var(--color-surface);
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 1.5rem;
        }

        .grid-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }

        /* --- Header --- */
        .header {
            margin-bottom: 1.5rem;
            text-align: center;
        }
        .header h1 {
            font-size: 1.875rem;
            font-weight: 700;
            color: #fff;
            margin: 0;
        }
        .header p {
            color: var(--color-text-secondary);
            margin-top: 0.5rem;
            margin-bottom: 0;
        }

        /* --- Input/Output Boxes --- */
        .io-label {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--color-text-secondary);
            margin-bottom: 0.5rem;
            display: block;
        }
        .io-box {
            width: 100%;
            padding: 1rem;
            background-color: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: 0.5rem;
            color: var(--color-text-primary);
            font-size: 0.875rem;
            overflow: auto;
            transition: all 200ms cubic-bezier(0.4, 0, 0.2, 1);
            box-sizing: border-box;
        }
        #inputText, #outputText {
            height: 485px;
        }
        #compactedOutput {
            height: 450px;
        }
        #inputText {
            resize: none;
        }
        #inputText:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--color-action);
            border-color: var(--color-action);
        }
        #outputText {
            white-space: pre-wrap;
            word-break: break-all;
        }

        /* --- Footer (Char Count & Buttons) --- */
        .output-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 0.5rem;
        }
        #charCount {
            font-size: 0.75rem;
            color: var(--color-text-muted);
            padding-right: 0.25rem;
        }
        .button-group {
            display: flex;
            gap: 0.5rem;
        }

        /* --- Buttons --- */
        .btn {
            color: #fff;
            font-weight: 700;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: all 200ms;
            font-size: 0.875rem;
            padding: 0.5rem 1rem;
        }
        .btn:focus {
            outline: none;
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.5); /* blue-300 equivalent */
        }
        .btn-primary {
            background-color: var(--color-action);
            padding: 0.75rem 2rem;
        }
        .btn-primary:hover {
            background-color: var(--color-action-hover);
            transform: scale(1.05);
        }
        .btn-discord {
            background-color: var(--color-primary);
        }
        .btn-discord:hover {
            background-color: var(--color-primary-hover);
        }
        .btn-copy {
            background-color: var(--color-secondary);
        }
        .btn-copy:hover {
            background-color: var(--color-secondary-hover);
        }
        .btn-copied {
            background-color: var(--color-text-muted);
        }
        
        /* --- Media Queries for Responsive Layout --- */
        @media (min-width: 640px) {
            .card { padding: 2rem; }
            .header h1 { font-size: 2.25rem; }
        }
        @media (min-width: 768px) {
            .grid-container { grid-template-columns: repeat(3, 1fr); }
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="card">
            <header class="header">
                <h1>Warhammer List Compactor</h1>
                <p>Paste your formatted text below to generate a compacted summary and see the raw JSON data.</p>
            </header>

            <div class="grid-container">
                <!-- Input Text Area -->
                <div>
                    <label for="inputText" class="io-label">Input Text</label>
                    <textarea id="inputText" class="io-box"></textarea>
                </div>

                <!-- JSON Output Area -->
                <div>
                    <label for="outputText" class="io-label">Parsed JavaScript Object</label>
                    <pre id="outputText" class="io-box"></pre>
                </div>

                <!-- Compacted Output Area -->
                <div>
                    <label for="compactedOutput" class="io-label">Compacted Output</label>
                    <div id="compactedOutput" class="io-box"></div>
                    <div class="output-footer">
                        <div id="charCount"></div>
                        <div class="button-group">
                             <button id="copyDiscordButton" class="btn btn-discord">Copy for Discord</button>
                             <button id="copyButton" class="btn btn-copy">Copy Text</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Action Button -->
            <div style="margin-top: 1.5rem; text-align: center;">
                <button id="parseButton" class="btn btn-primary">Parse Text</button>
            </div>
        </div>
    </div>

    <script>
        // Store the parsed data globally within the script's scope
        let parsedData = null;

        // --- Main Parsing Logic ---
        document.getElementById('parseButton').addEventListener('click', () => {
            const text = document.getElementById('inputText').value;
            const lines = text.split('\n');
            const result = {};
            let currentSection = null;
            let currentUnit = null;
            let currentSubUnit = null;

            // --- Helper function to add/consolidate items ---
            const addItemToTarget = (target, itemString) => {
                if (!target || !itemString) return;
                
                const withMatch = itemString.match(/(\d+)\s+with\s+(.*)/);
                if (withMatch) {
                    const quantity = parseInt(withMatch[1]);
                    const items = withMatch[2].split(',').map(s => s.trim());
                    items.forEach(itemName => {
                        const { quantity: innerQuantity, name } = parseItemString(itemName);
                        const numericInnerQuantity = parseInt(innerQuantity.replace('x', ''), 10);
                        const totalQuantity = quantity * numericInnerQuantity;
                        const existingItem = target.items.find(item => item.name === name);
                        if (existingItem) {
                            const existingQty = parseInt(existingItem.quantity.replace('x', ''));
                            existingItem.quantity = `${existingQty + totalQuantity}x`;
                        } else {
                            target.items.push({ quantity: `${totalQuantity}x`, name, items: [] });
                        }
                    });
                    return;
                }

                const { quantity, name } = parseItemString(itemString);
                const numericQuantity = parseInt(quantity.replace('x', ''), 10);
                const existingItem = target.items.find(item => item.name === name);

                if (existingItem) {
                    const existingQty = parseInt(existingItem.quantity.replace('x', ''));
                    existingItem.quantity = `${existingQty + numericQuantity}x`;
                } else {
                    target.items.push({ quantity, name, items: [] });
                }
            };

            // --- Regex patterns for different line formats ---
            const sectionHeaderRegex = /^[A-Z\s]+$/;
            const unitRegex = /^(\d+x?\s+)(.*?)(\s*\((\d+)\s*pts\))?$/;
            const summaryRegex = /^\+\s*([^:]+):\s*(.*)$/;
            const enhancementRegex = /^&\s*(.*)$/;
            const charLineRegex = /^(Char\d+):\s*(.*)/;
            const enhancementLineRegex = /^Enhancement:\s*(.*)/;
            const bulletItemRegex = /^\s*•\s*(.*)/;
            const indentedWithRegex = /^\s+(\d+)\s+with\s+(.*)/;
            const indentedBulletRegex = /^\s{2,}•\s*(.*)/;
            const simpleWithRegex = /^\d+\s+with\s+.*/;


            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (!trimmedLine) return;

                // --- Summary Parsing ---
                if (trimmedLine.startsWith('+') || trimmedLine.startsWith('&')) {
                    const summaryMatch = trimmedLine.match(summaryRegex);
                    const enhancementMatch = trimmedLine.match(enhancementRegex);
                    result.SUMMARY = result.SUMMARY || {};
                    result.SUMMARY.ENHANCEMENT = result.SUMMARY.ENHANCEMENT || [];

                    if (summaryMatch) {
                        const key = summaryMatch[1].trim().replace(/\s+/g, '_');
                        const value = summaryMatch[2].trim();
                        if (key === 'ENHANCEMENT') {
                            result.SUMMARY.ENHANCEMENT.push(value);
                        } else {
                            result.SUMMARY[key] = value;
                        }
                    } else if (enhancementMatch) {
                        result.SUMMARY.ENHANCEMENT.push(enhancementMatch[1].trim());
                    }
                    return;
                }
                
                // --- Indented Bullet (e.g., Warlord, Icon of Khorne) ---
                const indentedBulletMatch = line.match(indentedBulletRegex);
                if (indentedBulletMatch) {
                    const target = currentSubUnit || currentUnit;
                    addItemToTarget(target, indentedBulletMatch[1].trim());
                    return;
                }

                // --- Indented "with" items ---
                if (indentedWithRegex.test(line) && currentSubUnit) {
                    addItemToTarget(currentSubUnit, trimmedLine);
                    return;
                }
                
                // --- Section Header Parsing ---
                if (sectionHeaderRegex.test(trimmedLine) && !unitRegex.test(trimmedLine) && !charLineRegex.test(trimmedLine)) {
                    currentSection = trimmedLine;
                    result[currentSection] = result[currentSection] || [];
                    currentUnit = null;
                    currentSubUnit = null;
                    return;
                }

                // --- Char lines ---
                const charMatch = trimmedLine.match(charLineRegex);
                if (charMatch) {
                    currentSection = "CHARACTER";
                    result[currentSection] = result[currentSection] || [];
                    const unitMatch = charMatch[2].match(unitRegex);
                    if (unitMatch) {
                        currentUnit = {
                            quantity: unitMatch[1] ? unitMatch[1].trim() : '1x',
                            name: unitMatch[2].trim(),
                            points: unitMatch[4] ? parseInt(unitMatch[4], 10) : 0,
                            items: []
                        };
                        result[currentSection].push(currentUnit);
                        currentSubUnit = null;
                    }
                    return;
                }
                
                // --- Standalone Enhancement lines ---
                if (enhancementLineRegex.test(trimmedLine) && currentUnit) {
                    addItemToTarget(currentUnit, trimmedLine.match(enhancementLineRegex)[1].trim());
                    return;
                }

                // --- Bullet Point Items (Sub-units) ---
                const bulletMatch = trimmedLine.match(bulletItemRegex);
                if (bulletMatch) {
                    const itemContent = bulletMatch[1];
                    const subUnitMatch = itemContent.match(unitRegex);
                    if (subUnitMatch && currentUnit) {
                        currentSubUnit = {
                            quantity: subUnitMatch[1] ? subUnitMatch[1].trim() : '1x',
                            name: subUnitMatch[2].trim(),
                            points: 0,
                            items: []
                        };
                        currentUnit.items.push(currentSubUnit);
                    }
                    return;
                }

                // --- Simple "with" line (belongs to unit/sub-unit above it) ---
                if (simpleWithRegex.test(trimmedLine)) {
                    const target = currentSubUnit || currentUnit;
                    addItemToTarget(target, trimmedLine);
                    return;
                }

                // --- Standard Unit lines ---
                const standardUnitMatch = trimmedLine.match(unitRegex);
                if (standardUnitMatch) {
                    if (!currentSection) {
                        currentSection = "OTHER DATASHEETS";
                        result[currentSection] = result[currentSection] || [];
                    }
                    currentUnit = {
                        quantity: standardUnitMatch[1] ? standardUnitMatch[1].trim() : '1x',
                        name: standardUnitMatch[2].trim(),
                        points: standardUnitMatch[4] ? parseInt(standardUnitMatch[4], 10) : 0,
                        items: []
                    };
                    result[currentSection].push(currentUnit);
                    currentSubUnit = null;
                }
            });

            parsedData = result;
            document.getElementById('outputText').textContent = JSON.stringify(result, null, 2);
            displayCompactedOutput(result);
        });

        function parseItemString(itemString) {
            const match = itemString.match(/^(\d+x?\s+)?(.*)$/);
            if (match) {
                const quantity = match[1] ? match[1].trim() : '1x';
                const name = match[2].trim();
                return { quantity, name };
            }
            return { quantity: '1x', name: itemString };
        }

        function displayCompactedOutput(data) {
            const outputElement = document.getElementById('compactedOutput');
            let html = '';

            if (data.SUMMARY) {
                const summaryParts = [];
                if (data.SUMMARY.FACTION_KEYWORD) {
                    let faction = data.SUMMARY.FACTION_KEYWORD.replace("Chaos - ", "").replace("Xenos - ", "").replace("Imperium - ", "");
                    summaryParts.push(faction);
                }
                if (data.SUMMARY.DETACHMENT) summaryParts.push(`${data.SUMMARY.DETACHMENT}`);
                if (data.SUMMARY.TOTAL_ARMY_POINTS) summaryParts.push(`${data.SUMMARY.TOTAL_ARMY_POINTS}`);
                if (summaryParts.length > 0) {
                    html += `<div style="padding-bottom: 0.5rem; border-bottom: 1px solid var(--color-border);"><p style="font-size: 0.75rem; margin-bottom: 0.25rem; color: var(--color-text-secondary); font-weight: 600;">${summaryParts.join(' | ')}</p></div>`;
                }
            }

            html += `<div style="margin-top: 0.5rem;">`;
            for (const section in data) {
                if (section !== 'SUMMARY' && Array.isArray(data[section])) {
                    data[section].forEach(unit => {
                        const numericQuantity = parseInt(unit.quantity.replace('x', ''), 10);
                        const quantityDisplay = numericQuantity > 1 ? `${numericQuantity} ` : '';
                        html += `<div style="margin-bottom: 0.5rem;"><p style="color: var(--color-text-primary); font-weight: 600; font-size: 0.875rem;">${quantityDisplay}${unit.name} ${unit.points}</p>`;
                        if (unit.items && unit.items.length > 0) {
                            html += `<div style="padding-left: 1rem; font-size: 0.75rem; color: var(--color-text-secondary); font-weight: 400;">`;
                            unit.items.forEach(item => {
                                const itemNumericQty = parseInt(item.quantity.replace('x', ''), 10);
                                const itemQtyDisplay = itemNumericQty > 1 ? `${itemNumericQty} ` : '';
                                if (item.items && item.items.length > 0) {
                                    html += `<p style="font-weight: 500; color: var(--color-text-primary);">${itemQtyDisplay}${item.name}</p><div style="padding-left: 1rem;">`;
                                    item.items.forEach(subItem => {
                                        const subItemNumericQty = parseInt(subItem.quantity.replace('x', ''), 10);
                                        const subItemQtyDisplay = subItemNumericQty > 1 ? `${subItemNumericQty} ` : '';
                                        html += `<p>${subItemQtyDisplay}${subItem.name}</p>`;
                                    });
                                    html += `</div>`;
                                } else {
                                    html += `<p>${itemQtyDisplay}${item.name}</p>`;
                                }
                            });
                            html += `</div>`;
                        }
                        html += `</div>`;
                    });
                }
            }
            html += `</div>`;
            outputElement.innerHTML = html;
            
            const charCountElement = document.getElementById('charCount');
            const originalSize = document.getElementById('inputText').value.length;
            const compactedSize = outputElement.innerText.length;
            const difference = originalSize - compactedSize;
            const savings = originalSize > 0 ? ((difference / originalSize) * 100).toFixed(1) : 0;
            
            if (originalSize > 0) {
                 charCountElement.innerHTML = `Original: ${originalSize} | Compacted: ${compactedSize} | Savings: ${difference} (${savings}%)`;
            } else {
                charCountElement.innerHTML = '';
            }
        }

        function generateDiscordText(data) {
            let text = '```ansi\n';
            if (data.SUMMARY) {
                const summaryParts = [];
                if (data.SUMMARY.FACTION_KEYWORD) {
                    let faction = data.SUMMARY.FACTION_KEYWORD.replace("Chaos - ", "").replace("Xenos - ", "").replace("Imperium - ", "");
                    summaryParts.push(faction);
                }
                if (data.SUMMARY.DETACHMENT) summaryParts.push(data.SUMMARY.DETACHMENT);
                if (data.SUMMARY.TOTAL_ARMY_POINTS) summaryParts.push(data.SUMMARY.TOTAL_ARMY_POINTS);
                if (summaryParts.length > 0) {
                    const header = summaryParts.join(' | ');
                    text += `\u001b[1;33m${header}\u001b[0m\n`; // Bold Yellow Header
                    text += '\n'; // Add empty line after header
                }
            }

            let firstUnitOverall = true;
            for (const section in data) {
                if (section === 'SUMMARY' || !Array.isArray(data[section])) continue;
                
                data[section].forEach(unit => {
                    if (!firstUnitOverall) {
                        text += '\n'; 
                    }
                    const numericQuantity = parseInt(unit.quantity.replace('x', ''), 10);
                    const quantityDisplay = numericQuantity > 1 ? `${numericQuantity} ` : '';
                    const unitName = `${quantityDisplay}${unit.name}`;
                    const points = `${unit.points}`;
                    
                    text += `\u001b[0;31m* ${unitName}\u001b[0m [\u001b[0;33m${points}\u001b[0m]\n`;
                    
                    if (unit.items && unit.items.length > 0) {
                        unit.items.forEach(item => {
                            const itemNumericQty = parseInt(item.quantity.replace('x', ''), 10);
                            const itemQtyDisplay = itemNumericQty > 1 ? `${itemNumericQty} ` : '';
                            if (item.items && item.items.length > 0) {
                                text += `  \u001b[1;36m+ ${itemQtyDisplay}${item.name}\u001b[0m\n`; // Cyan
                                item.items.forEach(subItem => {
                                    const subItemNumericQty = parseInt(subItem.quantity.replace('x', ''), 10);
                                    const subItemQtyDisplay = subItemNumericQty > 1 ? `${subItemNumericQty} ` : '';
                                    text += `    - ${subItemQtyDisplay}${subItem.name}\n`;
                                });
                            } else {
                                text += `  - ${itemQtyDisplay}${item.name}\n`;
                            }
                        });
                    }
                    firstUnitOverall = false;
                });
            }
            text += '```';
            return text;
        }

        function copyTextToClipboard(text, button, isRichText = false) {
            if (!text) return;

            const listener = (e) => {
                if (isRichText) {
                    e.clipboardData.setData('text/html', text);
                }
                e.clipboardData.setData('text/plain', isRichText ? new DOMParser().parseFromString(text, 'text/html').body.innerText : text);
                e.preventDefault();
            };

            document.addEventListener('copy', listener);
            document.execCommand('copy');
            document.removeEventListener('copy', listener);

            const originalText = button.textContent;
            button.textContent = 'Copied!';
            button.classList.add('btn-copied');
            setTimeout(() => {
                button.textContent = originalText;
                button.classList.remove('btn-copied');
            }, 2000);
        }

        document.getElementById('copyButton').addEventListener('click', () => {
            const htmlToCopy = document.getElementById('compactedOutput').innerHTML;
            copyTextToClipboard(htmlToCopy, document.getElementById('copyButton'), true);
        });

        document.getElementById('copyDiscordButton').addEventListener('click', () => {
            if (parsedData) {
                const textToCopy = generateDiscordText(parsedData);
                copyTextToClipboard(textToCopy, document.getElementById('copyDiscordButton'), false);
            }
        });

        // Auto-parse on load for the new example
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('parseButton').click();
        });
    </script>

</body>
</html>
