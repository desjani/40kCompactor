<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warhammer List Compactor</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>

    <div class="container">
        <div class="card">
            <header class="header">
                <h1>Warhammer List Compactor</h1>
                <p>Paste your list below in "WTC" format to generate a compacted summary. Click "Copy Extended Version" for plain text output, or "Copy for Discord (Fancy)" for a colored Discord-friendly code block!</p>
            </header>

            <div class="grid-container">
                <!-- Input Column -->
                <div>
                    <label for="inputText" class="io-label">WTC Formatted List</label>
                    <textarea id="inputText" class="io-box"></textarea>
                    <div class="column-footer">
                        <div id="inputCharCount" class="char-count"></div>
                        <button id="parseButton" class="btn btn-primary">Compact this list</button>
                    </div>
                </div>

                <!-- Extended Output Column -->
                <div>
                    <label for="unabbreviatedOutput" class="io-label">Extended List</label>
                    <div id="unabbreviatedOutput" class="io-box"></div>
                     <div class="column-footer">
                        <div id="extendedCharCount" class="char-count"></div>
                        <button id="copyExtendedButton" class="btn btn-copy">Copy Extended Version</button>
                    </div>
                </div>

                <!-- Compacted Output Column -->
                <div>
                    <label for="compactedOutput" class="io-label">Compact List</label>
                    <div id="compactedOutput" class="io-box"></div>
                    <div class="column-footer">
                        <div id="compactCharCount" class="char-count"></div>
                        <div class="button-group">
                             <button id="copyCompactButton" class="btn btn-discord">Copy for Discord (Fancy)</button>
                             <button id="copyPlainDiscordButton" class="btn btn-discord">Copy Plain Text</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- App Footer with Contact Info -->
            <footer class="app-footer">
                <p>For feedback or questions, reach out to <a href="https://discord.com/users/Desjani" target="_blank">@Desjani</a> on Discord.</p>
            </footer>
        </div>
    </div>

    <script>
        // Store the parsed data globally within the script's scope
        let parsedData = null;
        let extendedPlainText = '';
        let compactPlainText = '';

        // --- Faction Themes ---
        const factionThemes = {
            "Chaos Daemons": { "--color-bg": "#4c1d4c", "--color-surface": "#6d286d", "--color-action": "#a855f7", "--color-action-hover": "#9333ea" },
            "Chaos Knights": { "--color-bg": "#262626", "--color-surface": "#404040", "--color-action": "#a1a1aa", "--color-action-hover": "#71717a" },
            "Chaos Space Marines": { "--color-bg": "#171717", "--color-surface": "#262626", "--color-action": "#ca8a04", "--color-action-hover": "#a16207" },
            "Death Guard": { "--color-bg": "#365314", "--color-surface": "#4d7c0f", "--color-action": "#84cc16", "--color-action-hover": "#65a30d" },
            "Emperor's Children": { "--color-bg": "#701a75", "--color-surface": "#86198f", "--color-action": "#d946ef", "--color-action-hover": "#c026d3" },
            "Thousand Sons": { "--color-bg": "#1e3a8a", "--color-surface": "#1e40af", "--color-action": "#3b82f6", "--color-action-hover": "#2563eb" },
            "World Eaters": { "--color-bg": "#4c1d1d", "--color-surface": "#7f1d1d", "--color-action": "#dc2626", "--color-action-hover": "#b91c1c" },
            "Adepta Sororitas": { "--color-bg": "#171717", "--color-surface": "#262626", "--color-action": "#dc2626", "--color-action-hover": "#b91c1c" },
            "Adeptus Custodes": { "--color-bg": "#78350f", "--color-surface": "#92400e", "--color-action": "#f59e0b", "--color-action-hover": "#d97706" },
            "Adeptus Mechanicus": { "--color-bg": "#7f1d1d", "--color-surface": "#991b1b", "--color-action": "#ef4444", "--color-action-hover": "#dc2626" },
            "Agents of the Imperium": { "--color-bg": "#262626", "--color-surface": "#404040", "--color-action": "#a1a1aa", "--color-action-hover": "#71717a" },
            "Astra Militarum": { "--color-bg": "#3f6212", "--color-surface": "#4d7c0f", "--color-action": "#84cc16", "--color-action-hover": "#65a30d" },
            "Grey Knights": { "--color-bg": "#374151", "--color-surface": "#4b5563", "--color-action": "#9ca3af", "--color-action-hover": "#6b7280" },
            "Imperial Knights": { "--color-bg": "#1e3a8a", "--color-surface": "#1e40af", "--color-action": "#f59e0b", "--color-action-hover": "#d97706" },
            "Black Templars": { "--color-bg": "#171717", "--color-surface": "#262626", "--color-action": "#e5e5e5", "--color-action-hover": "#a3a3a3" },
            "Blood Angels": { "--color-bg": "#7f1d1d", "--color-surface": "#991b1b", "--color-action": "#ef4444", "--color-action-hover": "#dc2626" },
            "Dark Angels": { "--color-bg": "#0f5132", "--color-surface": "#14532d", "--color-action": "#22c55e", "--color-action-hover": "#16a34a" },
            "Deathwatch": { "--color-bg": "#171717", "--color-surface": "#262626", "--color-action": "#9ca3af", "--color-action-hover": "#6b7280" },
            "Imperial Fists": { "--color-bg": "#854d0e", "--color-surface": "#a16207", "--color-action": "#facc15", "--color-action-hover": "#eab308" },
            "Iron Hands": { "--color-bg": "#171717", "--color-surface": "#262626", "--color-action": "#e5e5e5", "--color-action-hover": "#a3a3a3" },
            "Raven Guard": { "--color-bg": "#171717", "--color-surface": "#262626", "--color-action": "#e5e5e5", "--color-action-hover": "#a3a3a3" },
            "Salamanders": { "--color-bg": "#14532d", "--color-surface": "#166534", "--color-action": "#f59e0b", "--color-action-hover": "#d97706" },
            "Space Marines": { "--color-bg": "#1e3a8a", "--color-surface": "#1e40af", "--color-action": "#2563eb", "--color-action-hover": "#1d4ed8" },
            "Space Wolves": { "--color-bg": "#374151", "--color-surface": "#4b5563", "--color-action": "#facc15", "--color-action-hover": "#eab308" },
            "Ultramarines": { "--color-bg": "#1e3a8a", "--color-surface": "#1e40af", "--color-action": "#2563eb", "--color-action-hover": "#1d4ed8" },
            "White Scars": { "--color-bg": "#f9fafb", "--color-surface": "#f3f4f6", "--color-action": "#dc2626", "--color-action-hover": "#b91c1c" },
            "Aeldari": { "--color-bg": "#171717", "--color-surface": "#262626", "--color-action": "#fde047", "--color-action-hover": "#facc15" },
            "Drukhari": { "--color-bg": "#0f5132", "--color-surface": "#14532d", "--color-action": "#dc2626", "--color-action-hover": "#b91c1c" },
            "Genestealer Cults": { "--color-bg": "#4c1d4c", "--color-surface": "#6d286d", "--color-action": "#a855f7", "--color-action-hover": "#9333ea" },
            "Leagues of Votann": { "--color-bg": "#0e7490", "--color-surface": "#155e75", "--color-action": "#f97316", "--color-action-hover": "#ea580c" },
            "Necrons": { "--color-bg": "#262626", "--color-surface": "#404040", "--color-action": "#4ade80", "--color-action-hover": "#22c55e" },
            "Orks": { "--color-bg": "#14532d", "--color-surface": "#166534", "--color-action": "#22c55e", "--color-action-hover": "#16a34a" },
            "T'au Empire": { "--color-bg": "#854d0e", "--color-surface": "#a16207", "--color-action": "#f97316", "--color-action-hover": "#ea580c" },
            "Tyranids": { "--color-bg": "#4c1d4c", "--color-surface": "#6d286d", "--color-action": "#f472b6", "--color-action-hover": "#ec4899" }
        };

        // --- Abbreviation Database ---
        let factionAbbreviationDBs = {}; // Use let to allow reassignment

        document.addEventListener('DOMContentLoaded', () => {
            const parseButton = document.getElementById('parseButton');
            parseButton.disabled = true;
            parseButton.textContent = 'Loading DB...';

            fetch('./Wargear_tree.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    factionAbbreviationDBs = data;
                    console.log("Wargear database loaded successfully.");
                    parseButton.disabled = false;
                    parseButton.textContent = 'Compact this list';
                })
                .catch(error => {
                    console.error("Could not load wargear database:", error);
                    parseButton.textContent = 'Error: DB Load Failed';
                });
        })

        function abbreviate(itemName, unitName, fullFactionKeyword) {
            const searchOrder = [];
            const mainFaction = fullFactionKeyword ? fullFactionKeyword.replace(/^(Chaos|Xenos|Imperium)\s*-\s*/, '') : null;
            // Prioritize the specific faction if available
            if (mainFaction) {
                searchOrder.push(mainFaction);
            }
            // Add broader categories for cross-faction rules, if applicable.
            // These are specific general factions that might contain universal rules for their sub-factions.
            if (fullFactionKeyword.includes("Chaos")) {
                searchOrder.push("Chaos Knights", "Chaos Daemons");
            }
            if (fullFactionKeyword.includes("Imperium")) {
                searchOrder.push("Imperial Knights", "Imperial Agents");
            }
            if (fullFactionKeyword.includes("Adeptus Astartes")) {
                searchOrder.push("Space Marines");
            }
            // Special handling for Genestealer Cults and Tyranids due to their symbiotic relationship
            if (fullFactionKeyword.includes("Genestealer Cults") || fullFactionKeyword.includes("Tyranids")) {
                searchOrder.push("Genestealer Cults", "Tyranids");
            }
            const uniqueSearchOrder = [...new Set(searchOrder)];

            for (const faction of uniqueSearchOrder) {
                const rules = factionAbbreviationDBs[faction];
                if (!rules) continue;

                // Search priority within a faction's rules:
                // 1. Specific unit name, specific item name
                let foundRule = null;
                if (rules[unitName]) {
                    foundRule = rules[unitName].find(rule => rule.item === itemName);
                    if (foundRule) {
                        return foundRule.abbr;
                    }
                    // 2. Specific unit name, wildcard item ("*")
                    foundRule = rules[unitName].find(rule => rule.item === "*");
                    if (foundRule) {
                        return foundRule.abbr;
                    }
                }

                // 3. Wildcard unit ("*"), specific item name
                if (rules["*"]) {
                    foundRule = rules["*"].find(rule => rule.item === itemName);
                    if (foundRule) {
                        return foundRule.abbr;
                    }
                    // 4. Wildcard unit ("*"), wildcard item ("*")
                    foundRule = rules["*"].find(rule => rule.item === "*");
                    if (foundRule) {
                        return foundRule.abbr;
                    }
                }
            }
            // If no abbreviation is found after checking all relevant factions, return the original item name
            return itemName;
        }
    }
        document.getElementById('parseButton').addEventListener('click', () => {
            const text = document.getElementById('inputText').value;
            const lines = text.split('\n');
            const result = {};
            let currentSection = null, currentUnit = null, currentSubUnit = null, factionKeyword = null;

            const addItemToTarget = (target, itemString, unitContextName) => {
                if (!target || !itemString) return;
                const withMatch = itemString.match(/(\d+)\s+with\s+(.*)/);
                if (withMatch) {
                    const quantity = parseInt(withMatch[1]);
                    const items = withMatch[2].split(',').map(s => s.trim());
                    items.forEach(itemName => {
                        const { quantity: innerQuantity, name } = parseItemString(itemName);
                        const numericInnerQuantity = parseInt(innerQuantity.replace('x', ''), 10);
                        const totalQuantity = quantity * numericInnerQuantity;
                        const nameshort = abbreviate(name, unitContextName, factionKeyword);
                        const existingItem = target.items.find(item => item.name === name);
                        if (existingItem) {
                            const existingQty = parseInt(existingItem.quantity.replace('x', ''));
                            existingItem.quantity = `${existingQty + totalQuantity}x`;
                        } else {
                            target.items.push({ quantity: `${totalQuantity}x`, name, nameshort, items: [] });
                        }
                    });
                    return;
                }
                const { quantity, name } = parseItemString(itemString);
                const nameshort = abbreviate(name, unitContextName, factionKeyword);
                const numericQuantity = parseInt(quantity.replace('x', ''), 10);
                const existingItem = target.items.find(item => item.name === name);
                if (existingItem) {
                    const existingQty = parseInt(existingItem.quantity.replace('x', ''));
                    existingItem.quantity = `${existingQty + numericQuantity}x`;
                } else {
                    target.items.push({ quantity, name, nameshort, items: [] });
                }
            };

            const sectionHeaderRegex = /^[A-Z\s]+$/;
            const unitRegex = /^(\d+x?\s+)(.*?)(\s*\((\d+)\s*pts\))?$/;
            const summaryRegex = /^\+\s*([^:]+):\s*(.*)$/;
            const enhancementRegex = /^&\s*(.*)$/;
            const charLineRegex = /^(Char\d+):\s*(.*)/;
            const enhancementLineRegex = /^Enhancement:\s*(.*)/;
            const bulletItemRegex = /^\s*•\s*(.*)/;
            const indentedWithRegex = /^\s+(\d+)\s+with\s+(.*)/;
            const indentedBulletRegex = /^\s{2,}•\s*(.*)/;
            const simpleWithRegex = /^\d+\s+with\s+.*/;

            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (!trimmedLine) return;
                if (trimmedLine.startsWith('+') || trimmedLine.startsWith('&')) {
                    const summaryMatch = trimmedLine.match(summaryRegex);
                    const enhancementMatch = trimmedLine.match(enhancementRegex);
                    result.SUMMARY = result.SUMMARY || { ENHANCEMENT: [] };
                    if (summaryMatch) {
                        const key = summaryMatch[1].trim().replace(/\s+/g, '_');
                        const value = summaryMatch[2].trim();
                        if (key === 'ENHANCEMENT') result.SUMMARY.ENHANCEMENT.push(value);
                        else result.SUMMARY[key] = value;
                    } else if (enhancementMatch) {
                        result.SUMMARY.ENHANCEMENT.push(enhancementMatch[1].trim());
                    }
                    if (!factionKeyword && result.SUMMARY.FACTION_KEYWORD) {
                        factionKeyword = result.SUMMARY.FACTION_KEYWORD;
                    }
                    return;
                }
                const indentedBulletMatch = line.match(indentedBulletRegex);
                if (indentedBulletMatch) {
                    const target = currentSubUnit || currentUnit;
                    const unitContextName = currentSubUnit ? currentSubUnit.name : currentUnit.name;
                    addItemToTarget(target, indentedBulletMatch[1].trim(), unitContextName);
                    return;
                }
                if (indentedWithRegex.test(line) && currentSubUnit) {
                    addItemToTarget(currentSubUnit, trimmedLine, currentSubUnit.name);
                    return;
                }
                if (sectionHeaderRegex.test(trimmedLine) && !unitRegex.test(trimmedLine) && !charLineRegex.test(trimmedLine)) {
                    currentSection = trimmedLine;
                    result[currentSection] = result[currentSection] || [];
                    currentUnit = null;
                    currentSubUnit = null;
                    return;
                }
                const charMatch = trimmedLine.match(charLineRegex);
                if (charMatch) {
                    currentSection = "CHARACTER";
                    result[currentSection] = result[currentSection] || [];
                    const unitMatch = charMatch[2].match(unitRegex);
                    if (unitMatch) {
                        currentUnit = {
                            quantity: unitMatch[1] ? unitMatch[1].trim() : '1x',
                            name: unitMatch[2].trim(),
                            points: unitMatch[4] ? parseInt(unitMatch[4], 10) : 0,
                            items: []
                        };
                        result[currentSection].push(currentUnit);
                        currentSubUnit = null;
                    }
                    return;
                }
                if (enhancementLineRegex.test(trimmedLine) && currentUnit) {
                    addItemToTarget(currentUnit, trimmedLine.match(enhancementLineRegex)[1].trim(), currentUnit.name);
                    return;
                }
                const bulletMatch = trimmedLine.match(bulletItemRegex);
                if (bulletMatch) {
                    const itemContent = bulletMatch[1];
                    const subUnitMatch = itemContent.match(unitRegex);
                    if (subUnitMatch && currentUnit) {
                        currentSubUnit = {
                            quantity: subUnitMatch[1] ? subUnitMatch[1].trim() : '1x',
                            name: subUnitMatch[2].trim(),
                            points: 0,
                            items: []
                        };
                        currentUnit.items.push(currentSubUnit);
                    }
                    return;
                }
                if (simpleWithRegex.test(trimmedLine)) {
                    const target = currentSubUnit || currentUnit;
                    const unitContextName = currentSubUnit ? currentSubUnit.name : currentUnit.name;
                    addItemToTarget(target, trimmedLine, unitContextName);
                    return;
                }
                const standardUnitMatch = trimmedLine.match(unitRegex);
                if (standardUnitMatch) {
                    if (!currentSection) {
                        currentSection = "OTHER DATASHEETS";
                        result[currentSection] = result[currentSection] || [];
                    }
                    currentUnit = {
                        quantity: standardUnitMatch[1] ? standardUnitMatch[1].trim() : '1x',
                        name: standardUnitMatch[2].trim(),
                        points: standardUnitMatch[4] ? parseInt(standardUnitMatch[4], 10) : 0,
                        items: []
                    };
                    result[currentSection].push(currentUnit);
                    currentSubUnit = null;
                }
            });
            parsedData = result;
            const extendedOutput = generateOutput(result, false);
            document.getElementById('unabbreviatedOutput').innerHTML = extendedOutput.html;
            extendedPlainText = extendedOutput.plainText;
            const compactOutput = generateOutput(result, true);
            document.getElementById('compactedOutput').innerHTML = compactOutput.html;
            compactPlainText = compactOutput.plainText;
            updateCharCounts();
            applyTheme(factionKeyword);
        });

        function parseItemString(itemString) {
            const match = itemString.match(/^(\d+x?\s+)?(.*)$/);
            if (match) {
                const quantity = match[1] ? match[1].trim() : '1x';
                const name = match[2].trim();
                return { quantity, name };
            }
            return { quantity: '1x', name: itemString };
        }

        function generateOutput(data, useAbbreviations) {
            let html = '', plainText = '';
            const factionKeyword = data.SUMMARY?.FACTION_KEYWORD || '';
            const faction = factionKeyword.replace(/^(Chaos|Xenos|Imperium)\s*-\s*/, '');
            if (data.SUMMARY) {
                const summaryParts = [];
                if (faction) summaryParts.push(faction);
                if (data.SUMMARY.DETACHMENT) summaryParts.push(`${data.SUMMARY.DETACHMENT}`);
                if (data.SUMMARY.TOTAL_ARMY_POINTS) summaryParts.push(`${data.SUMMARY.TOTAL_ARMY_POINTS}`);
                if (summaryParts.length > 0) {
                    const summaryText = summaryParts.join(' | ');
                    html += `<div style="padding-bottom: 0.5rem; border-bottom: 1px solid var(--color-border);"><p style="font-size: 0.75rem; margin-bottom: 0.25rem; color: var(--color-text-secondary); font-weight: 600;">${summaryText}</p></div>`;
                    plainText += summaryText + '\n-------------------------------------\n';
                }
            }
            html += `<div style="margin-top: 0.5rem;">`;
            let firstUnitOverall = true;
            for (const section in data) {
                if (section !== 'SUMMARY' && Array.isArray(data[section])) {
                    data[section].forEach(unit => {
                        if (!firstUnitOverall) {
                            html += '<div style="height: 0.5rem;"></div>';
                            plainText += '\n';
                        }
                        const numericQuantity = parseInt(unit.quantity.replace('x', ''), 10);
                        const quantityDisplay = numericQuantity > 1 ? `${numericQuantity} ` : '';
                        const unitText = `${quantityDisplay}${unit.name} ${unit.points}`;
                        html += `<div><p style="color: var(--color-text-primary); font-weight: 600; font-size: 0.875rem; margin-bottom: 0.25rem;">${unitText}</p>`;
                        plainText += `* ${unitText}\n`;
                        if (unit.items && unit.items.length > 0) {
                            html += `<div style="padding-left: 1rem; font-size: 0.75rem; color: var(--color-text-secondary); font-weight: 400;">`;
                            unit.items.forEach(item => {
                                if (useAbbreviations && item.nameshort === "NULL") return;
                                const itemNumericQty = parseInt(item.quantity.replace('x', ''), 10);
                                const itemQtyDisplay = itemNumericQty > 1 ? `${itemNumericQty} ` : '';
                                const itemName = useAbbreviations ? item.nameshort : item.name;
                                const itemText = `${itemQtyDisplay}${itemName}`;
                                if (item.items && item.items.length > 0) {
                                    html += `<p style="font-weight: 500; color: var(--color-text-primary); margin: 0;">${itemText}</p><div style="padding-left: 1rem;">`;
                                    plainText += `  + ${itemText}\n`;
                                    item.items.forEach(subItem => {
                                        if (useAbbreviations && subItem.nameshort === "NULL") return;
                                        const subItemNumericQty = parseInt(subItem.quantity.replace('x', ''), 10);
                                        const subItemQtyDisplay = subItemNumericQty > 1 ? `${subItemNumericQty} ` : '';
                                        const subItemText = `${subItemQtyDisplay}${useAbbreviations ? subItem.nameshort : subItem.name}`;
                                        html += `<p style="margin: 0;">${subItemText}</p>`;
                                        plainText += `    - ${subItemText}\n`;
                                    });
                                    html += `</div>`;
                                } else {
                                    html += `<p style="margin: 0;">${itemText}</p>`;
                                    plainText += `  - ${itemText}\n`;
                                }
                            });
                            html += `</div>`;
                        }
                        html += `</div>`;
                        firstUnitOverall = false;
                    });
                }
            }
            html += `</div>`;
            return { html, plainText };
        }    
    function updateCharCounts() {
            const originalSize = document.getElementById('inputText').value.length;
            const extendedSize = extendedPlainText.trim().length;
            const compactSize = compactPlainText.trim().length;
            
            document.getElementById('inputCharCount').textContent = `Characters: ${originalSize}`;

            if (originalSize > 0) {
                const extendedSavings = originalSize - extendedSize;
                const extendedSavingsPercent = ((extendedSavings / originalSize) * 100).toFixed(1);
                document.getElementById('extendedCharCount').innerHTML = `Characters: ${extendedSize} | Savings: ${extendedSavings} (${extendedSavingsPercent}%)`;

                const compactSavings = originalSize - compactSize;
                const compactSavingsPercent = ((compactSavings / originalSize) * 100).toFixed(1);
                document.getElementById('compactCharCount').innerHTML = `Characters: ${compactSize} | Savings: ${compactSavings} (${compactSavingsPercent}%)`;
            } else {
                document.getElementById('extendedCharCount').innerHTML = '';
                document.getElementById('compactCharCount').innerHTML = '';
            }
        }

        function generateDiscordText(data, plain) {
            const factionKeyword = data.SUMMARY?.FACTION_KEYWORD || '';
            let text = plain ? '' : '```ansi\n';

            if (data.SUMMARY) {
                const summaryParts = [];
                if (data.SUMMARY.FACTION_KEYWORD) {
                    let faction = data.SUMMARY.FACTION_KEYWORD.replace("Chaos - ", "").replace("Xenos - ", "").replace("Imperium - ", "");
                    summaryParts.push(faction);
                }
                if (data.SUMMARY.DETACHMENT) summaryParts.push(data.SUMMARY.DETACHMENT);
                if (data.SUMMARY.TOTAL_ARMY_POINTS) summaryParts.push(data.SUMMARY.TOTAL_ARMY_POINTS);
                if (summaryParts.length > 0) {
                    const header = summaryParts.join(' | ');
                    text += plain ? `${header}\n` : `\u001b[1;33m${header}\u001b[0m\n\n`;
                }
            }
            let firstUnitOverall = true;
            for (const section in data) {
                if (section === 'SUMMARY' || !Array.isArray(data[section])) continue;
                data[section].forEach(unit => {
                    if (!firstUnitOverall) text += '\n'; 
                    const numericQuantity = parseInt(unit.quantity.replace('x', ''), 10);
                    const quantityDisplay = numericQuantity > 1 ? `${numericQuantity} ` : '';
                    const unitName = `${quantityDisplay}${unit.name}`;
                    const points = `${unit.points}`;
                    text += plain ? `* ${unitName} [${points}]\n` : `\u001b[0;31m* ${unitName}\u001b[0m [\u001b[0;33m${points}\u001b[0m]\n`;
                    if (unit.items && unit.items.length > 0) {
                        unit.items.forEach(item => {
                            if (item.nameshort === "NULL") return;
                            const itemNumericQty = parseInt(item.quantity.replace('x', ''), 10);
                            const itemQtyDisplay = itemNumericQty > 1 ? `${itemNumericQty} ` : '';
                            if (item.items && item.items.length > 0) {
                                text += plain ? `  + ${itemQtyDisplay}${item.nameshort}\n` : `  \u001b[1;36m+ ${itemQtyDisplay}${item.nameshort}\u001b[0m\n`;
                                item.items.forEach(subItem => {
                                     if (subItem.nameshort === "NULL") return;
                                    const subItemNumericQty = parseInt(subItem.quantity.replace('x', ''), 10);
                                    const subItemQtyDisplay = subItemNumericQty > 1 ? `${subItemNumericQty} ` : '';
                                    text += `    - ${subItemQtyDisplay}${subItem.nameshort}\n`;
                                });
                            } else {
                                text += `  - ${itemQtyDisplay}${item.nameshort}\n`;
                            }
                        });
                    }
                    firstUnitOverall = false;
                });
            }
            if (!plain) text += '```';
            return text;
        }
        
        function applyTheme(factionKeyword) {
            const root = document.documentElement;
            const mainFaction = factionKeyword ? factionKeyword.replace(/^(Chaos|Xenos|Imperium)\s*-\s*/, '') : null;
            const theme = factionThemes[mainFaction];
            const defaultTheme = {
                "--color-bg": "#1f2937",
                "--color-surface": "#374151",
                "--color-action": "#4b5563",
                "--color-action-hover": "#6b7280"
            };
            const colorsToSet = theme || defaultTheme;
            for (const [key, value] of Object.entries(colorsToSet)) {
                root.style.setProperty(key, value);
            }
        }

        function copyTextToClipboard(text, button) {
            if (!text) return;
            const listener = (e) => {
                e.clipboardData.setData('text/plain', text);
                e.preventDefault();
            };
            document.addEventListener('copy', listener);
            document.execCommand('copy');
            document.removeEventListener('copy', listener);
            const originalText = button.textContent;
            button.textContent = 'Copied!';
            button.classList.add('btn-copied');
            setTimeout(() => {
                button.textContent = originalText;
                button.classList.remove('btn-copied');
            }, 2000);
        }

        document.getElementById('copyExtendedButton').addEventListener('click', () => {
             copyTextToClipboard(extendedPlainText.trim(), document.getElementById('copyExtendedButton'));
        });

        document.getElementById('copyCompactButton').addEventListener('click', () => {
            if (parsedData) {
                const textToCopy = generateDiscordText(parsedData, false);
                copyTextToClipboard(textToCopy, document.getElementById('copyCompactButton'));
            }
        });

        document.getElementById('copyPlainDiscordButton').addEventListener('click', () => {
            if (parsedData) {
                const textToCopy = generateDiscordText(parsedData, true);
                copyTextToClipboard(textToCopy.trim(), document.getElementById('copyPlainDiscordButton'));
            }
        });
    </script>

</body>
</html>