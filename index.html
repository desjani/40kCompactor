<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warhammer List Compactor</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>

    <div class="container">
        <div class="card">
            <header class="header">
                <h1>Warhammer List Compactor</h1>
                <p>Paste your list below in "GW" or "WTC" format to generate a compacted summary. Click "Copy Extended Version" for plain text output, or "Copy for Discord (Fancy)" for a colored Discord-friendly code block!</p>
            </header>

            <div class="grid-container">
                <!-- Input Column -->
                <div>
                    <label for="inputText" class="io-label">Paste List here (GW or WTC Format)</label>
                    <textarea id="inputText" class="io-box"></textarea>
                    <div class="column-footer">
                        <div id="inputCharCount" class="char-count"></div>
                        <button id="parseButton" class="btn btn-primary">Compact this list</button>
                    </div>
                </div>

                <!-- Extended Output Column -->
                <div>
                    <label for="unabbreviatedOutput" class="io-label">Extended List</label>
                    <div id="unabbreviatedOutput" class="io-box"></div>
                     <div class="column-footer">
                        <div id="extendedCharCount" class="char-count"></div>
                        <button id="copyExtendedButton" class="btn btn-copy">Copy Extended Version</button>
                    </div>
                </div>

                <!-- Compacted Output Column -->
                <div>
                    <label for="compactedOutput" class="io-label">Compact List</label>
                    <div id="compactedOutput" class="io-box"></div>
                    <div class="column-footer">
                        <div id="compactCharCount" class="char-count"></div>
                        <div class="button-group">
                             <button id="copyCompactButton" class="btn btn-discord">Copy for Discord (Fancy)</button>
                             <button id="copyPlainDiscordButton" class="btn btn-discord">Copy Plain Text</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- App Footer with Contact Info -->
            <footer class="app-footer">
                <p>For feedback or questions, reach out to <a href="https://discord.com/users/Desjani" target="_blank">@Desjani</a> on Discord.</p>
            </footer>
        </div>
    </div>

    <script>
        // Store the parsed data globally within the script's scope
        let parsedData = null;
        let extendedPlainText = '';
        let compactPlainText = '';

        // --- Abbreviation Database ---
        let factionAbbreviationDBs = {}; // Use let to allow reassignment

        document.addEventListener('DOMContentLoaded', () => {
            const parseButton = document.getElementById('parseButton');
            parseButton.disabled = true;
            parseButton.textContent = 'Loading DB...';

            fetch('./Wargear_tree.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    factionAbbreviationDBs = data;
                    console.log("Wargear database loaded successfully.");
                    parseButton.disabled = false;
                    parseButton.textContent = 'Compact this list';
                })
                .catch(error => {
                    console.error("Could not load wargear database:", error);
                    parseButton.textContent = 'Error: DB Load Failed';
                });
        })

        function flexibleItemMatch(rule, itemName) {
            const ruleItemLower = rule.item.toLowerCase();
            const itemNameLower = itemName.toLowerCase();
            if (ruleItemLower === itemNameLower) return true; // Exact match
            if (ruleItemLower === itemNameLower + 's') return true; // input: cutter, rule: cutters
            if (itemNameLower.endsWith('s') && ruleItemLower === itemNameLower.slice(0, -1)) return true; // input: cutters, rule: cutter
            return false;
        }

        function abbreviate(itemName, unitName, fullFactionKeyword) {
             const searchOrder = [];
             const mainFaction = fullFactionKeyword ? (fullFactionKeyword.split(' - ').pop() || fullFactionKeyword) : null;

             if (mainFaction) {
                 searchOrder.push(mainFaction);
             }
             // Add broader categories for cross-faction rules.
             if (fullFactionKeyword.includes("Chaos")) {
                 searchOrder.push("Chaos Space Marines", "Chaos Knights", "Chaos Daemons");
             }
             if (fullFactionKeyword.includes("Imperium")) {
                 searchOrder.push("Imperial Knights", "Agents of the Imperium");
             }
             if (fullFactionKeyword.includes("Adeptus Astartes")) {
                 searchOrder.push("Space Marines");
             }
             if (fullFactionKeyword.includes("Genestealer Cults") || fullFactionKeyword.includes("Tyranids")) {
                 searchOrder.push("Genestealer Cults", "Tyranids");
             }
             const factionsToSearch = [...new Set(searchOrder)];

             const findRule = () => {
                 // --- First Pass: Prioritize specific unit matches across all relevant factions ---
                 for (const faction of factionsToSearch) {
                     const rules = factionAbbreviationDBs[faction];
                     if (!rules) continue;
                     const unitRulesKey = Object.keys(rules).find(key => key.toLowerCase() === unitName.toLowerCase());
                     const unitRules = unitRulesKey ? rules[unitRulesKey] : null;
                     if (!unitRules) continue;
                     let foundRule = unitRules.find(rule => flexibleItemMatch(rule, itemName));
                     if (foundRule) return foundRule;
                     foundRule = unitRules.find(rule => rule.item === "*");
                     if (foundRule) return foundRule;
                 }
                 // --- Second Pass: Check for wildcard unit matches if no specific unit match was found ---
                 for (const faction of factionsToSearch) {
                     const rules = factionAbbreviationDBs[faction];
                     if (!rules || !rules["*"]) continue;
                     let foundRule = rules["*"].find(rule => flexibleItemMatch(rule, itemName));
                     if (foundRule) return foundRule;
                     foundRule = rules["*"].find(rule => rule.item === "*");
                     if (foundRule) return foundRule;
                 }
                 return null;
             };

             const rule = findRule();
             return rule ? rule.abbr : itemName;
        }
        document.getElementById('parseButton').addEventListener('click', () => {
            const text = document.getElementById('inputText').value;
            const lines = text.split('\n');
            const result = {};
            let currentSection = null, currentUnit = null, currentSubUnit = null, factionKeyword = null;

            const addItemToTarget = (target, itemString, unitContextName, itemType = 'wargear') => {
                if (!target || !itemString) return;
                const withMatch = itemString.match(/(\d+)\s+with\s+(.*)/);
                if (withMatch) {
                    const quantity = parseInt(withMatch[1]);
                    const items = withMatch[2].split(',').map(s => s.trim());
                    items.forEach(itemName => {
                        const { quantity: innerQuantity, name } = parseItemString(itemName);
                        const numericInnerQuantity = parseInt(innerQuantity.replace('x', ''), 10);
                        const totalQuantity = quantity * numericInnerQuantity;
                        const nameshort = abbreviate(name, unitContextName, factionKeyword);
                        const existingItem = target.items.find(item => item.name === name);
                        if (existingItem) {
                            const existingQty = parseInt(existingItem.quantity.replace('x', ''));
                            existingItem.quantity = `${existingQty + totalQuantity}x`;
                        } else {
                            target.items.push({ quantity: `${totalQuantity}x`, name, nameshort, items: [], type: itemType });
                        }
                    });
                    return;
                }
                const { quantity, name } = parseItemString(itemString);
                const nameshort = itemType === 'special' ? name : abbreviate(name, unitContextName, factionKeyword);
                const numericQuantity = parseInt(quantity.replace('x', ''), 10);
                const existingItem = target.items.find(item => item.name === name);
                if (existingItem) {
                    const existingQty = parseInt(existingItem.quantity.replace('x', ''));
                    existingItem.quantity = `${existingQty + numericQuantity}x`;
                } else {
                    target.items.push({ quantity, name, nameshort, items: [], type: itemType });
                }
            };

            const parseAndAddEnhancement = (enhancementContent, targetUnit) => {
                if (!targetUnit) return;
                const pointsRegex = /\s*\((.*?)\)$/;
                const pointsMatch = enhancementContent.match(pointsRegex);
                
                let enhancementName = enhancementContent;
                let enhancementPoints = '';

                if (pointsMatch) {
                    enhancementName = enhancementContent.replace(pointsRegex, '').trim();
                    const pointsText = pointsMatch[1].replace(/\s*pts/i, '');
                    enhancementPoints = `(${pointsText})`;
                }

                const abbreviation = enhancementName.split(/[\s-]+/).map(word => word.charAt(0)).join('').toUpperCase();
                const shortText = `E: ${abbreviation} ${enhancementPoints}`.trim();
                targetUnit.items.push({ quantity: '1x', name: `Enhancement: ${enhancementContent}`, nameshort: shortText, items: [], type: 'special' });
            };

            const sectionHeaderRegex = /^[A-Z\s]+$/;
            const unitRegex = /^(\d+x?\s+)(.*?)(\s*\((\d+)\s*pts\))?$/;
            const summaryRegex = /^\+\s*([^:]+):\s*(.*)$/;
            const enhancementRegex = /^&\s*(.*)$/;
            const charLineRegex = /^(Char\d+):\s*(.*)/;
            const enhancementLineRegex = /^Enhancement:\s*(.*)/;
            const bulletItemRegex = /^\s*•\s*(.*)/;
            const indentedWithRegex = /^\s+(\d+)\s+with\s+(.*)/;
            const indentedBulletRegex = /^\s{2,}•\s*(.*)/;
            const simpleWithRegex = /^\d+\s+with\s+.*/;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();
                if (!trimmedLine) continue;

                // --- Handle non-unit lines first ---
                if (trimmedLine.startsWith('+') || trimmedLine.startsWith('&')) {
                    const summaryMatch = trimmedLine.match(summaryRegex);
                    const enhancementMatch = trimmedLine.match(enhancementRegex);
                    result.SUMMARY = result.SUMMARY || { ENHANCEMENT: [] };
                    if (summaryMatch) {
                        const key = summaryMatch[1].trim().replace(/\s+/g, '_');
                        const value = summaryMatch[2].trim();
                        if (key === 'ENHANCEMENT') result.SUMMARY.ENHANCEMENT.push(value);
                        else result.SUMMARY[key] = value;
                    } else if (enhancementMatch) {
                        result.SUMMARY.ENHANCEMENT.push(enhancementMatch[1].trim());
                    }
                    if (!factionKeyword && result.SUMMARY.FACTION_KEYWORD) {
                        factionKeyword = result.SUMMARY.FACTION_KEYWORD;
                    }
                    continue;
                }
                if (sectionHeaderRegex.test(trimmedLine) && !unitRegex.test(trimmedLine) && !charLineRegex.test(trimmedLine)) {
                    currentSection = trimmedLine;
                    result[currentSection] = result[currentSection] || [];
                    currentUnit = null;
                    currentSubUnit = null;
                    continue;
                }

                // --- Handle unit lines (Character or standard) ---
                const charMatch = trimmedLine.match(charLineRegex);
                const standardUnitMatch = trimmedLine.match(unitRegex);
                // A main unit is a character line, or any non-indented, non-bullet line that looks like a unit.
                const isMainUnitLine = (charMatch || (standardUnitMatch && !line.startsWith(' ') && !line.startsWith('\t') && !trimmedLine.startsWith('•'))) && !simpleWithRegex.test(trimmedLine);

                if (isMainUnitLine) {
                    currentSection = "CHARACTER";
                    if (!charMatch) {
                        currentSection = currentSection || "OTHER DATASHEETS";
                    }
                    result[currentSection] = result[currentSection] || [];
                    const unitContent = charMatch ? charMatch[2] : trimmedLine;
                    const finalUnitMatch = unitContent.match(unitRegex);

                    if (finalUnitMatch) {
                        currentUnit = {
                            quantity: finalUnitMatch[1] ? finalUnitMatch[1].trim() : '1x',
                            name: finalUnitMatch[2].trim(),
                            points: finalUnitMatch[4] ? parseInt(finalUnitMatch[4], 10) : 0,
                            items: []
                        };
                        result[currentSection].push(currentUnit);
                        currentSubUnit = null;
                    }
                    continue;
                }

                // --- Handle items within a unit (wargear, subunits, etc.) ---
                if (currentUnit) {
                    const bulletMatch = trimmedLine.match(bulletItemRegex);
                    const isIndented = line.startsWith(' ') || line.startsWith('\t');

                    if (bulletMatch) {
                        const itemContent = bulletMatch[1].trim();

                        // Handle GW-style enhancements, which are bulleted items with (+XX pts)
                        const gwEnhancementRegex = /\(\s*\+\d+.*?\)$/;
                        if (gwEnhancementRegex.test(itemContent)) {
                            parseAndAddEnhancement(itemContent, currentUnit);
                            continue;
                        }

                        // Ignore noise lines that just repeat a unit name
                        const cleanItemContent = itemContent.replace(/^\d+x?\s*/, '').trim();
                        if (cleanItemContent.toLowerCase() === currentUnit.name.toLowerCase() || (currentSubUnit && cleanItemContent.toLowerCase() === currentSubUnit.name.toLowerCase())) {
                            continue;
                        }

                        if (isIndented) {
                            // Indented bullet is always wargear for the current context.
                            const target = currentSubUnit || currentUnit;
                            const itemType = itemContent.toLowerCase() === 'warlord' ? 'special' : 'wargear';
                            addItemToTarget(target, itemContent, currentUnit.name, itemType);
                        } else {
                            // Non-indented bullet. Could be a subunit header or wargear for the main unit.
                            const nextLine = (i + 1 < lines.length) ? lines[i + 1] : '';
                            const nextLineIsIndented = nextLine.trim() !== '' && (nextLine.startsWith(' ') || nextLine.startsWith('\t'));
                            const subUnitMatch = itemContent.match(unitRegex);

                            if (subUnitMatch && nextLineIsIndented) {
                                // It's a subunit header because it's followed by indented items.
                                currentSubUnit = {
                                    quantity: subUnitMatch[1] ? subUnitMatch[1].trim() : '1x',
                                    name: subUnitMatch[2].trim(),
                                    points: 0,
                                    items: []
                                };
                                currentUnit.items.push(currentSubUnit);
                            } else {
                                // It's wargear for the main unit.
                                const itemType = itemContent.toLowerCase() === 'warlord' ? 'special' : 'wargear';
                                addItemToTarget(currentUnit, itemContent, currentUnit.name, itemType);
                                currentSubUnit = null; // Reset subunit context after adding item to main unit
                            }
                        }
                    } else if (isIndented) { // This handles indented lines without bullets
                        // This is an indented line without a bullet (e.g., a "with" line). It's wargear for the current context.
                        const target = currentSubUnit || currentUnit;
                        addItemToTarget(target, trimmedLine, currentUnit.name);
                    } else if (enhancementLineRegex.test(trimmedLine)) {
                        parseAndAddEnhancement(trimmedLine.match(enhancementLineRegex)[1].trim(), currentUnit);
                    } else if (simpleWithRegex.test(trimmedLine)) {
                        // This is a non-indented "with" line, treat as wargear for the current context.
                        const target = currentSubUnit || currentUnit;
                        addItemToTarget(target, trimmedLine, currentUnit.name);
                    }
                }
            }
            parsedData = result;
            const extendedOutput = generateOutput(result, false);
            document.getElementById('unabbreviatedOutput').innerHTML = extendedOutput.html;
            extendedPlainText = extendedOutput.plainText;
            const compactOutput = generateOutput(result, true);
            document.getElementById('compactedOutput').innerHTML = compactOutput.html;
            compactPlainText = compactOutput.plainText;
            updateCharCounts();
        });

        function parseItemString(itemString) {
            const match = itemString.match(/^(\d+x?\s+)?(.*)$/);
            if (match) {
                const quantity = match[1] ? match[1].trim() : '1x';
                const name = match[2].trim();
                return { quantity, name };
            }
            return { quantity: '1x', name: itemString };
        }

        function renderUnitItems(items, useAbbreviations, plainTextPrefix) {
            let html = '', plainText = '';
            const specialItems = items.filter(item => item.type === 'special');
            const wargearItems = items.filter(item => item.type !== 'special' && (!useAbbreviations || item.nameshort !== "NULL"));

            if (wargearItems.length > 0) {
                wargearItems.sort((a, b) => parseInt(b.quantity.replace('x', ''), 10) - parseInt(a.quantity.replace('x', ''), 10));
                const wargearStrings = wargearItems.map(item => {
                    const itemNumericQty = parseInt(item.quantity.replace('x', ''), 10);
                    const itemQtyDisplay = itemNumericQty > 1 ? `${itemNumericQty} ` : '';
                    const itemName = useAbbreviations ? item.nameshort : item.name;
                    return `${itemQtyDisplay}${itemName}`;
                });
                if (useAbbreviations) {
                    html += `<p style="margin: 0;">${wargearStrings.join(', ')}</p>`;
                    plainText += `${plainTextPrefix}${wargearStrings.join(', ')}\n`;
                } else {
                    wargearStrings.forEach(str => {
                        html += `<p style="margin: 0;">${str}</p>`;
                        plainText += `${plainTextPrefix}${str}\n`;
                    });
                }
            }

            if (specialItems.length > 0) {
                specialItems.forEach(item => {
                    const itemName = useAbbreviations ? item.nameshort : item.name;
                    html += `<p style="margin: 0;">${itemName}</p>`;
                    plainText += `${plainTextPrefix}${itemName}\n`;
                });
            }
            return { html, plainText };
        }

        function generateOutput(data, useAbbreviations) {
            let html = '', plainText = '';
            const factionKeyword = data.SUMMARY?.FACTION_KEYWORD || '';
            const faction = (factionKeyword.split(' - ').pop() || factionKeyword);
            if (data.SUMMARY) {
                const summaryParts = [];
                if (faction) summaryParts.push(faction);
                if (data.SUMMARY.DETACHMENT) summaryParts.push(`${data.SUMMARY.DETACHMENT}`);
                if (data.SUMMARY.TOTAL_ARMY_POINTS) summaryParts.push(`${data.SUMMARY.TOTAL_ARMY_POINTS}`);
                if (summaryParts.length > 0) {
                    const summaryText = summaryParts.join(' | ');
                    html += `<div style="padding-bottom: 0.5rem; border-bottom: 1px solid var(--color-border);"><p style="font-size: 0.75rem; margin-bottom: 0.25rem; color: var(--color-text-secondary); font-weight: 600;">${summaryText}</p></div>`;
                    plainText += summaryText + '\n-------------------------------------\n';
                }
            }
            html += `<div style="margin-top: 0.5rem;">`;
            let firstUnitOverall = true;
            for (const section in data) {
                if (section !== 'SUMMARY' && Array.isArray(data[section])) {
                    data[section].forEach(unit => {
                        const numericQuantity = parseInt(unit.quantity.replace('x', ''), 10);
                        const quantityDisplay = numericQuantity > 1 ? `${numericQuantity} ` : '';
                        const unitText = `${quantityDisplay}${unit.name} ${unit.points}`;
                        html += `<div><p style="color: var(--color-text-primary); font-weight: 600; font-size: 0.875rem; margin-bottom: 0.25rem;">${unitText}</p>`;
                        plainText += `* ${unitText}\n`;
                        if (unit.items && unit.items.length > 0) {
                            const hasVisibleItems = !useAbbreviations || unit.items.some(item => {
                                if (item.points !== undefined) { 
                                    return item.items && item.items.some(subItem => subItem.nameshort !== "NULL" || subItem.type === 'special');
                                }
                                return item.nameshort !== "NULL" || item.type === 'special';
                            });

                            if (hasVisibleItems) {
                                html += `<div style="padding-left: 1rem; font-size: 0.75rem; color: var(--color-text-secondary); font-weight: 400;">`;
                                const allItems = [...unit.items];
                                const topLevelItems = allItems.filter(item => item.points === undefined);
                                const subunitItems = allItems.filter(item => item.points !== undefined).sort((a, b) => parseInt(a.quantity.replace('x', ''), 10) - parseInt(b.quantity.replace('x', ''), 10));

                                const topLevelRender = renderUnitItems(topLevelItems, useAbbreviations, '  - ');
                                html += topLevelRender.html;
                                plainText += topLevelRender.plainText;

                                subunitItems.forEach(item => {
                                    const subUnitHasVisibleItems = !useAbbreviations || (item.items && item.items.some(subItem => subItem.nameshort !== "NULL" || subItem.type === 'special'));
                                    if (subUnitHasVisibleItems) {
                                        const itemNumericQty = parseInt(item.quantity.replace('x', ''), 10);
                                        const itemQtyDisplay = itemNumericQty > 1 ? `${itemNumericQty} ` : '';
                                        const itemText = `${itemQtyDisplay}${item.name}`;
                                        html += `<p style="font-weight: 500; color: var(--color-text-primary); margin: 0;">${itemText}</p>`;
                                        plainText += `  + ${itemText}\n`;

                                        const subunitRender = renderUnitItems(item.items, useAbbreviations, '    - ');
                                        html += `<div style="padding-left: 1rem;">${subunitRender.html}</div>`;
                                        plainText += subunitRender.plainText;
                                    }
                                });
                                html += `</div>`;
                            }
                        }
                        html += `</div>`;
                        firstUnitOverall = false;
                    });
                }
            }
            html += `</div>`;
            return { html, plainText };
        }    
    function updateCharCounts() {
            const originalSize = document.getElementById('inputText').value.length;
            const extendedSize = extendedPlainText.trim().length;
            const compactSize = compactPlainText.trim().length;
            
            document.getElementById('inputCharCount').textContent = `Characters: ${originalSize}`;

            if (originalSize > 0) {
                const extendedSavings = originalSize - extendedSize;
                const extendedSavingsPercent = ((extendedSavings / originalSize) * 100).toFixed(1);
                document.getElementById('extendedCharCount').innerHTML = `Characters: ${extendedSize} | Savings: ${extendedSavings} (${extendedSavingsPercent}%)`;

                const compactSavings = originalSize - compactSize;
                const compactSavingsPercent = ((compactSavings / originalSize) * 100).toFixed(1);
                document.getElementById('compactCharCount').innerHTML = `Characters: ${compactSize} | Savings: ${compactSavings} (${compactSavingsPercent}%)`;
            } else {
                document.getElementById('extendedCharCount').innerHTML = '';
                document.getElementById('compactCharCount').innerHTML = '';
            }
        }

        function renderDiscordItems(items, plain, prefix) {
            let text = '';
            const specialItems = items.filter(item => item.type === 'special');
            const wargearItems = items.filter(item => item.type !== 'special' && item.nameshort !== "NULL");

            if (wargearItems.length > 0) {
                wargearItems.sort((a, b) => parseInt(b.quantity.replace('x', ''), 10) - parseInt(a.quantity.replace('x', ''), 10));
                const wargearStrings = wargearItems.map(item => {
                    const itemNumericQty = parseInt(item.quantity.replace('x', ''), 10);
                    const itemQtyDisplay = itemNumericQty > 1 ? `${itemNumericQty} ` : '';
                    return `${itemQtyDisplay}${item.nameshort}`;
                });
                text += `${prefix}${wargearStrings.join(', ')}\n`;
            }

            if (specialItems.length > 0) {
                specialItems.forEach(item => {
                    text += `${prefix}${item.nameshort}\n`;
                });
            }
            return text;
        }

        function generateDiscordText(data, plain) {
            const factionKeyword = data.SUMMARY?.FACTION_KEYWORD || '';
            let text = plain ? '' : '```ansi\n';

            if (data.SUMMARY) {
                const summaryParts = [];
                if (data.SUMMARY.FACTION_KEYWORD) {
                    const faction = (data.SUMMARY.FACTION_KEYWORD.split(' - ').pop() || data.SUMMARY.FACTION_KEYWORD);
                    summaryParts.push(faction);
                                }
                if (data.SUMMARY.DETACHMENT) summaryParts.push(data.SUMMARY.DETACHMENT);
                if (data.SUMMARY.TOTAL_ARMY_POINTS) summaryParts.push(data.SUMMARY.TOTAL_ARMY_POINTS);
                if (summaryParts.length > 0) {
                    const header = summaryParts.join(' | ');
                    text += plain ? `${header}\n` : `\u001b[1;33m${header}\u001b[0m\n\n`;
                }
            }
            let firstUnitOverall = true;
            for (const section in data) {
                if (section === 'SUMMARY' || !Array.isArray(data[section])) continue;
                data[section].forEach(unit => {
                    const numericQuantity = parseInt(unit.quantity.replace('x', ''), 10);
                    const quantityDisplay = numericQuantity > 1 ? `${numericQuantity} ` : '';
                    const unitName = `${quantityDisplay}${unit.name}`;
                    const points = `${unit.points}`;
                    text += plain ? `* ${unitName} [${points}]\n` : `\u001b[0;31m* ${unitName}\u001b[0m [\u001b[0;33m${points}\u001b[0m]\n`;
                    if (unit.items && unit.items.length > 0) {
                        const hasVisibleItems = plain || unit.items.some(item => {
                            if (item.points !== undefined) {
                                return item.items && item.items.some(subItem => subItem.nameshort !== "NULL" || subItem.type === 'special');
                            }
                            return item.nameshort !== "NULL" || item.type === 'special';
                        });

                        if (hasVisibleItems) {
                            const allItems = [...unit.items];
                            const topLevelItems = allItems.filter(item => item.points === undefined);
                            const subunitItems = allItems.filter(item => item.points !== undefined).sort((a, b) => parseInt(a.quantity.replace('x', ''), 10) - parseInt(b.quantity.replace('x', ''), 10));

                            text += renderDiscordItems(topLevelItems, plain, '  - ');

                            subunitItems.forEach(item => {
                                const subUnitHasVisibleItems = plain || (item.items && item.items.some(subItem => subItem.nameshort !== "NULL" || subItem.type === 'special'));
                                if (subUnitHasVisibleItems) {
                                    const itemNumericQty = parseInt(item.quantity.replace('x', ''), 10);
                                    const itemQtyDisplay = itemNumericQty > 1 ? `${itemNumericQty} ` : '';
                                    const subunitName = item.name;
                                    text += plain ? `  + ${itemQtyDisplay}${subunitName}\n` : `  \u001b[1;36m+ ${itemQtyDisplay}${subunitName}\u001b[0m\n`;

                                    text += renderDiscordItems(item.items, plain, '    - ');
                                }
                            });
                        }
                    }
                    firstUnitOverall = false;
                });
            }
            if (!plain) text += '```';
            return text;
        }
        
        async function copyTextToClipboard(text, button) {
            if (!text) return;
            if (!navigator.clipboard) {
                console.error('Clipboard API not available');
                return;
            }
            try {
                await navigator.clipboard.writeText(text);
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.classList.add('btn-copied');
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('btn-copied');
                }, 2000);
            } catch (err) {
                console.error('Failed to copy text: ', err);
            }
        }

        document.getElementById('copyExtendedButton').addEventListener('click', () => {
             copyTextToClipboard(extendedPlainText.trim(), document.getElementById('copyExtendedButton'));
        });

        document.getElementById('copyCompactButton').addEventListener('click', () => {
            if (parsedData) {
                const textToCopy = generateDiscordText(parsedData, false);
                copyTextToClipboard(textToCopy, document.getElementById('copyCompactButton'));
            }
        });

        document.getElementById('copyPlainDiscordButton').addEventListener('click', () => {
            if (parsedData) {
                const textToCopy = generateDiscordText(parsedData, true);
                copyTextToClipboard(textToCopy.trim(), document.getElementById('copyPlainDiscordButton'));
            }
        });
    </script>

</body>
</html>